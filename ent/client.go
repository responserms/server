// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/responserms/server/ent/migrate"

	"github.com/responserms/server/ent/activation"
	"github.com/responserms/server/ent/authsession"
	"github.com/responserms/server/ent/maplayer"
	"github.com/responserms/server/ent/maptype"
	"github.com/responserms/server/ent/metadata"
	"github.com/responserms/server/ent/metadataschema"
	"github.com/responserms/server/ent/player"
	"github.com/responserms/server/ent/playeridentifier"
	"github.com/responserms/server/ent/server"
	"github.com/responserms/server/ent/servertype"
	"github.com/responserms/server/ent/sessiontoken"
	"github.com/responserms/server/ent/user"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Activation is the client for interacting with the Activation builders.
	Activation *ActivationClient
	// AuthSession is the client for interacting with the AuthSession builders.
	AuthSession *AuthSessionClient
	// MapLayer is the client for interacting with the MapLayer builders.
	MapLayer *MapLayerClient
	// MapType is the client for interacting with the MapType builders.
	MapType *MapTypeClient
	// Metadata is the client for interacting with the Metadata builders.
	Metadata *MetadataClient
	// MetadataSchema is the client for interacting with the MetadataSchema builders.
	MetadataSchema *MetadataSchemaClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// PlayerIdentifier is the client for interacting with the PlayerIdentifier builders.
	PlayerIdentifier *PlayerIdentifierClient
	// Server is the client for interacting with the Server builders.
	Server *ServerClient
	// ServerType is the client for interacting with the ServerType builders.
	ServerType *ServerTypeClient
	// SessionToken is the client for interacting with the SessionToken builders.
	SessionToken *SessionTokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Activation = NewActivationClient(c.config)
	c.AuthSession = NewAuthSessionClient(c.config)
	c.MapLayer = NewMapLayerClient(c.config)
	c.MapType = NewMapTypeClient(c.config)
	c.Metadata = NewMetadataClient(c.config)
	c.MetadataSchema = NewMetadataSchemaClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.PlayerIdentifier = NewPlayerIdentifierClient(c.config)
	c.Server = NewServerClient(c.config)
	c.ServerType = NewServerTypeClient(c.config)
	c.SessionToken = NewSessionTokenClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Activation:       NewActivationClient(cfg),
		AuthSession:      NewAuthSessionClient(cfg),
		MapLayer:         NewMapLayerClient(cfg),
		MapType:          NewMapTypeClient(cfg),
		Metadata:         NewMetadataClient(cfg),
		MetadataSchema:   NewMetadataSchemaClient(cfg),
		Player:           NewPlayerClient(cfg),
		PlayerIdentifier: NewPlayerIdentifierClient(cfg),
		Server:           NewServerClient(cfg),
		ServerType:       NewServerTypeClient(cfg),
		SessionToken:     NewSessionTokenClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:           cfg,
		Activation:       NewActivationClient(cfg),
		AuthSession:      NewAuthSessionClient(cfg),
		MapLayer:         NewMapLayerClient(cfg),
		MapType:          NewMapTypeClient(cfg),
		Metadata:         NewMetadataClient(cfg),
		MetadataSchema:   NewMetadataSchemaClient(cfg),
		Player:           NewPlayerClient(cfg),
		PlayerIdentifier: NewPlayerIdentifierClient(cfg),
		Server:           NewServerClient(cfg),
		ServerType:       NewServerTypeClient(cfg),
		SessionToken:     NewSessionTokenClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Activation.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Activation.Use(hooks...)
	c.AuthSession.Use(hooks...)
	c.MapLayer.Use(hooks...)
	c.MapType.Use(hooks...)
	c.Metadata.Use(hooks...)
	c.MetadataSchema.Use(hooks...)
	c.Player.Use(hooks...)
	c.PlayerIdentifier.Use(hooks...)
	c.Server.Use(hooks...)
	c.ServerType.Use(hooks...)
	c.SessionToken.Use(hooks...)
	c.User.Use(hooks...)
}

// ActivationClient is a client for the Activation schema.
type ActivationClient struct {
	config
}

// NewActivationClient returns a client for the Activation from the given config.
func NewActivationClient(c config) *ActivationClient {
	return &ActivationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activation.Hooks(f(g(h())))`.
func (c *ActivationClient) Use(hooks ...Hook) {
	c.hooks.Activation = append(c.hooks.Activation, hooks...)
}

// Create returns a create builder for Activation.
func (c *ActivationClient) Create() *ActivationCreate {
	mutation := newActivationMutation(c.config, OpCreate)
	return &ActivationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Activation entities.
func (c *ActivationClient) CreateBulk(builders ...*ActivationCreate) *ActivationCreateBulk {
	return &ActivationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Activation.
func (c *ActivationClient) Update() *ActivationUpdate {
	mutation := newActivationMutation(c.config, OpUpdate)
	return &ActivationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivationClient) UpdateOne(a *Activation) *ActivationUpdateOne {
	mutation := newActivationMutation(c.config, OpUpdateOne, withActivation(a))
	return &ActivationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivationClient) UpdateOneID(id int) *ActivationUpdateOne {
	mutation := newActivationMutation(c.config, OpUpdateOne, withActivationID(id))
	return &ActivationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Activation.
func (c *ActivationClient) Delete() *ActivationDelete {
	mutation := newActivationMutation(c.config, OpDelete)
	return &ActivationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ActivationClient) DeleteOne(a *Activation) *ActivationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ActivationClient) DeleteOneID(id int) *ActivationDeleteOne {
	builder := c.Delete().Where(activation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivationDeleteOne{builder}
}

// Query returns a query builder for Activation.
func (c *ActivationClient) Query() *ActivationQuery {
	return &ActivationQuery{config: c.config}
}

// Get returns a Activation entity by its id.
func (c *ActivationClient) Get(ctx context.Context, id int) (*Activation, error) {
	return c.Query().Where(activation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivationClient) GetX(ctx context.Context, id int) *Activation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Activation.
func (c *ActivationClient) QueryUser(a *Activation) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activation.Table, activation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, activation.UserTable, activation.UserColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActor queries the actor edge of a Activation.
func (c *ActivationClient) QueryActor(a *Activation) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activation.Table, activation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, activation.ActorTable, activation.ActorPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivationClient) Hooks() []Hook {
	return c.hooks.Activation
}

// AuthSessionClient is a client for the AuthSession schema.
type AuthSessionClient struct {
	config
}

// NewAuthSessionClient returns a client for the AuthSession from the given config.
func NewAuthSessionClient(c config) *AuthSessionClient {
	return &AuthSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authsession.Hooks(f(g(h())))`.
func (c *AuthSessionClient) Use(hooks ...Hook) {
	c.hooks.AuthSession = append(c.hooks.AuthSession, hooks...)
}

// Create returns a create builder for AuthSession.
func (c *AuthSessionClient) Create() *AuthSessionCreate {
	mutation := newAuthSessionMutation(c.config, OpCreate)
	return &AuthSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthSession entities.
func (c *AuthSessionClient) CreateBulk(builders ...*AuthSessionCreate) *AuthSessionCreateBulk {
	return &AuthSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthSession.
func (c *AuthSessionClient) Update() *AuthSessionUpdate {
	mutation := newAuthSessionMutation(c.config, OpUpdate)
	return &AuthSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthSessionClient) UpdateOne(as *AuthSession) *AuthSessionUpdateOne {
	mutation := newAuthSessionMutation(c.config, OpUpdateOne, withAuthSession(as))
	return &AuthSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthSessionClient) UpdateOneID(id int) *AuthSessionUpdateOne {
	mutation := newAuthSessionMutation(c.config, OpUpdateOne, withAuthSessionID(id))
	return &AuthSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthSession.
func (c *AuthSessionClient) Delete() *AuthSessionDelete {
	mutation := newAuthSessionMutation(c.config, OpDelete)
	return &AuthSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthSessionClient) DeleteOne(as *AuthSession) *AuthSessionDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthSessionClient) DeleteOneID(id int) *AuthSessionDeleteOne {
	builder := c.Delete().Where(authsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthSessionDeleteOne{builder}
}

// Query returns a query builder for AuthSession.
func (c *AuthSessionClient) Query() *AuthSessionQuery {
	return &AuthSessionQuery{config: c.config}
}

// Get returns a AuthSession entity by its id.
func (c *AuthSessionClient) Get(ctx context.Context, id int) (*AuthSession, error) {
	return c.Query().Where(authsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthSessionClient) GetX(ctx context.Context, id int) *AuthSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthSessionClient) Hooks() []Hook {
	return c.hooks.AuthSession
}

// MapLayerClient is a client for the MapLayer schema.
type MapLayerClient struct {
	config
}

// NewMapLayerClient returns a client for the MapLayer from the given config.
func NewMapLayerClient(c config) *MapLayerClient {
	return &MapLayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `maplayer.Hooks(f(g(h())))`.
func (c *MapLayerClient) Use(hooks ...Hook) {
	c.hooks.MapLayer = append(c.hooks.MapLayer, hooks...)
}

// Create returns a create builder for MapLayer.
func (c *MapLayerClient) Create() *MapLayerCreate {
	mutation := newMapLayerMutation(c.config, OpCreate)
	return &MapLayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MapLayer entities.
func (c *MapLayerClient) CreateBulk(builders ...*MapLayerCreate) *MapLayerCreateBulk {
	return &MapLayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MapLayer.
func (c *MapLayerClient) Update() *MapLayerUpdate {
	mutation := newMapLayerMutation(c.config, OpUpdate)
	return &MapLayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MapLayerClient) UpdateOne(ml *MapLayer) *MapLayerUpdateOne {
	mutation := newMapLayerMutation(c.config, OpUpdateOne, withMapLayer(ml))
	return &MapLayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MapLayerClient) UpdateOneID(id int) *MapLayerUpdateOne {
	mutation := newMapLayerMutation(c.config, OpUpdateOne, withMapLayerID(id))
	return &MapLayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MapLayer.
func (c *MapLayerClient) Delete() *MapLayerDelete {
	mutation := newMapLayerMutation(c.config, OpDelete)
	return &MapLayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MapLayerClient) DeleteOne(ml *MapLayer) *MapLayerDeleteOne {
	return c.DeleteOneID(ml.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MapLayerClient) DeleteOneID(id int) *MapLayerDeleteOne {
	builder := c.Delete().Where(maplayer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MapLayerDeleteOne{builder}
}

// Query returns a query builder for MapLayer.
func (c *MapLayerClient) Query() *MapLayerQuery {
	return &MapLayerQuery{config: c.config}
}

// Get returns a MapLayer entity by its id.
func (c *MapLayerClient) Get(ctx context.Context, id int) (*MapLayer, error) {
	return c.Query().Where(maplayer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MapLayerClient) GetX(ctx context.Context, id int) *MapLayer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a MapLayer.
func (c *MapLayerClient) QueryMetadata(ml *MapLayer) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(maplayer.Table, maplayer.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, maplayer.MetadataTable, maplayer.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMapType queries the map_type edge of a MapLayer.
func (c *MapLayerClient) QueryMapType(ml *MapLayer) *MapTypeQuery {
	query := &MapTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(maplayer.Table, maplayer.FieldID, id),
			sqlgraph.To(maptype.Table, maptype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, maplayer.MapTypeTable, maplayer.MapTypeColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MapLayerClient) Hooks() []Hook {
	return c.hooks.MapLayer
}

// MapTypeClient is a client for the MapType schema.
type MapTypeClient struct {
	config
}

// NewMapTypeClient returns a client for the MapType from the given config.
func NewMapTypeClient(c config) *MapTypeClient {
	return &MapTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `maptype.Hooks(f(g(h())))`.
func (c *MapTypeClient) Use(hooks ...Hook) {
	c.hooks.MapType = append(c.hooks.MapType, hooks...)
}

// Create returns a create builder for MapType.
func (c *MapTypeClient) Create() *MapTypeCreate {
	mutation := newMapTypeMutation(c.config, OpCreate)
	return &MapTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MapType entities.
func (c *MapTypeClient) CreateBulk(builders ...*MapTypeCreate) *MapTypeCreateBulk {
	return &MapTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MapType.
func (c *MapTypeClient) Update() *MapTypeUpdate {
	mutation := newMapTypeMutation(c.config, OpUpdate)
	return &MapTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MapTypeClient) UpdateOne(mt *MapType) *MapTypeUpdateOne {
	mutation := newMapTypeMutation(c.config, OpUpdateOne, withMapType(mt))
	return &MapTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MapTypeClient) UpdateOneID(id int) *MapTypeUpdateOne {
	mutation := newMapTypeMutation(c.config, OpUpdateOne, withMapTypeID(id))
	return &MapTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MapType.
func (c *MapTypeClient) Delete() *MapTypeDelete {
	mutation := newMapTypeMutation(c.config, OpDelete)
	return &MapTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MapTypeClient) DeleteOne(mt *MapType) *MapTypeDeleteOne {
	return c.DeleteOneID(mt.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MapTypeClient) DeleteOneID(id int) *MapTypeDeleteOne {
	builder := c.Delete().Where(maptype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MapTypeDeleteOne{builder}
}

// Query returns a query builder for MapType.
func (c *MapTypeClient) Query() *MapTypeQuery {
	return &MapTypeQuery{config: c.config}
}

// Get returns a MapType entity by its id.
func (c *MapTypeClient) Get(ctx context.Context, id int) (*MapType, error) {
	return c.Query().Where(maptype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MapTypeClient) GetX(ctx context.Context, id int) *MapType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a MapType.
func (c *MapTypeClient) QueryMetadata(mt *MapType) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(maptype.Table, maptype.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, maptype.MetadataTable, maptype.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMapLayers queries the map_layers edge of a MapType.
func (c *MapTypeClient) QueryMapLayers(mt *MapType) *MapLayerQuery {
	query := &MapLayerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(maptype.Table, maptype.FieldID, id),
			sqlgraph.To(maplayer.Table, maplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, maptype.MapLayersTable, maptype.MapLayersColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServers queries the servers edge of a MapType.
func (c *MapTypeClient) QueryServers(mt *MapType) *ServerQuery {
	query := &ServerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := mt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(maptype.Table, maptype.FieldID, id),
			sqlgraph.To(server.Table, server.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, maptype.ServersTable, maptype.ServersColumn),
		)
		fromV = sqlgraph.Neighbors(mt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MapTypeClient) Hooks() []Hook {
	return c.hooks.MapType
}

// MetadataClient is a client for the Metadata schema.
type MetadataClient struct {
	config
}

// NewMetadataClient returns a client for the Metadata from the given config.
func NewMetadataClient(c config) *MetadataClient {
	return &MetadataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetadataClient) Use(hooks ...Hook) {
	c.hooks.Metadata = append(c.hooks.Metadata, hooks...)
}

// Create returns a create builder for Metadata.
func (c *MetadataClient) Create() *MetadataCreate {
	mutation := newMetadataMutation(c.config, OpCreate)
	return &MetadataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Metadata entities.
func (c *MetadataClient) CreateBulk(builders ...*MetadataCreate) *MetadataCreateBulk {
	return &MetadataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Metadata.
func (c *MetadataClient) Update() *MetadataUpdate {
	mutation := newMetadataMutation(c.config, OpUpdate)
	return &MetadataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataClient) UpdateOne(m *Metadata) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadata(m))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataClient) UpdateOneID(id int) *MetadataUpdateOne {
	mutation := newMetadataMutation(c.config, OpUpdateOne, withMetadataID(id))
	return &MetadataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Metadata.
func (c *MetadataClient) Delete() *MetadataDelete {
	mutation := newMetadataMutation(c.config, OpDelete)
	return &MetadataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MetadataClient) DeleteOne(m *Metadata) *MetadataDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MetadataClient) DeleteOneID(id int) *MetadataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataDeleteOne{builder}
}

// Query returns a query builder for Metadata.
func (c *MetadataClient) Query() *MetadataQuery {
	return &MetadataQuery{config: c.config}
}

// Get returns a Metadata entity by its id.
func (c *MetadataClient) Get(ctx context.Context, id int) (*Metadata, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataClient) GetX(ctx context.Context, id int) *Metadata {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchema queries the schema edge of a Metadata.
func (c *MetadataClient) QuerySchema(m *Metadata) *MetadataSchemaQuery {
	query := &MetadataSchemaQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(metadataschema.Table, metadataschema.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, metadata.SchemaTable, metadata.SchemaColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Metadata.
func (c *MetadataClient) QueryUser(m *Metadata) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, metadata.UserTable, metadata.UserColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMapType queries the map_type edge of a Metadata.
func (c *MetadataClient) QueryMapType(m *Metadata) *MapTypeQuery {
	query := &MapTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadata.Table, metadata.FieldID, id),
			sqlgraph.To(maptype.Table, maptype.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, metadata.MapTypeTable, metadata.MapTypeColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataClient) Hooks() []Hook {
	return c.hooks.Metadata
}

// MetadataSchemaClient is a client for the MetadataSchema schema.
type MetadataSchemaClient struct {
	config
}

// NewMetadataSchemaClient returns a client for the MetadataSchema from the given config.
func NewMetadataSchemaClient(c config) *MetadataSchemaClient {
	return &MetadataSchemaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadataschema.Hooks(f(g(h())))`.
func (c *MetadataSchemaClient) Use(hooks ...Hook) {
	c.hooks.MetadataSchema = append(c.hooks.MetadataSchema, hooks...)
}

// Create returns a create builder for MetadataSchema.
func (c *MetadataSchemaClient) Create() *MetadataSchemaCreate {
	mutation := newMetadataSchemaMutation(c.config, OpCreate)
	return &MetadataSchemaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MetadataSchema entities.
func (c *MetadataSchemaClient) CreateBulk(builders ...*MetadataSchemaCreate) *MetadataSchemaCreateBulk {
	return &MetadataSchemaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MetadataSchema.
func (c *MetadataSchemaClient) Update() *MetadataSchemaUpdate {
	mutation := newMetadataSchemaMutation(c.config, OpUpdate)
	return &MetadataSchemaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetadataSchemaClient) UpdateOne(ms *MetadataSchema) *MetadataSchemaUpdateOne {
	mutation := newMetadataSchemaMutation(c.config, OpUpdateOne, withMetadataSchema(ms))
	return &MetadataSchemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetadataSchemaClient) UpdateOneID(id int) *MetadataSchemaUpdateOne {
	mutation := newMetadataSchemaMutation(c.config, OpUpdateOne, withMetadataSchemaID(id))
	return &MetadataSchemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MetadataSchema.
func (c *MetadataSchemaClient) Delete() *MetadataSchemaDelete {
	mutation := newMetadataSchemaMutation(c.config, OpDelete)
	return &MetadataSchemaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MetadataSchemaClient) DeleteOne(ms *MetadataSchema) *MetadataSchemaDeleteOne {
	return c.DeleteOneID(ms.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MetadataSchemaClient) DeleteOneID(id int) *MetadataSchemaDeleteOne {
	builder := c.Delete().Where(metadataschema.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetadataSchemaDeleteOne{builder}
}

// Query returns a query builder for MetadataSchema.
func (c *MetadataSchemaClient) Query() *MetadataSchemaQuery {
	return &MetadataSchemaQuery{config: c.config}
}

// Get returns a MetadataSchema entity by its id.
func (c *MetadataSchemaClient) Get(ctx context.Context, id int) (*MetadataSchema, error) {
	return c.Query().Where(metadataschema.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetadataSchemaClient) GetX(ctx context.Context, id int) *MetadataSchema {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a MetadataSchema.
func (c *MetadataSchemaClient) QueryMetadata(ms *MetadataSchema) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ms.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(metadataschema.Table, metadataschema.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, metadataschema.MetadataTable, metadataschema.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(ms.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MetadataSchemaClient) Hooks() []Hook {
	return c.hooks.MetadataSchema
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Create returns a create builder for Player.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id int) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PlayerClient) DeleteOneID(id int) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{config: c.config}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id int) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id int) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a Player.
func (c *PlayerClient) QueryMetadata(pl *Player) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, player.MetadataTable, player.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServers queries the servers edge of a Player.
func (c *PlayerClient) QueryServers(pl *Player) *ServerQuery {
	query := &ServerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(server.Table, server.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, player.ServersTable, player.ServersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Player.
func (c *PlayerClient) QueryUser(pl *Player) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, player.UserTable, player.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIdentifiers queries the identifiers edge of a Player.
func (c *PlayerClient) QueryIdentifiers(pl *Player) *PlayerIdentifierQuery {
	query := &PlayerIdentifierQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(playeridentifier.Table, playeridentifier.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, player.IdentifiersTable, player.IdentifiersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// PlayerIdentifierClient is a client for the PlayerIdentifier schema.
type PlayerIdentifierClient struct {
	config
}

// NewPlayerIdentifierClient returns a client for the PlayerIdentifier from the given config.
func NewPlayerIdentifierClient(c config) *PlayerIdentifierClient {
	return &PlayerIdentifierClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `playeridentifier.Hooks(f(g(h())))`.
func (c *PlayerIdentifierClient) Use(hooks ...Hook) {
	c.hooks.PlayerIdentifier = append(c.hooks.PlayerIdentifier, hooks...)
}

// Create returns a create builder for PlayerIdentifier.
func (c *PlayerIdentifierClient) Create() *PlayerIdentifierCreate {
	mutation := newPlayerIdentifierMutation(c.config, OpCreate)
	return &PlayerIdentifierCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlayerIdentifier entities.
func (c *PlayerIdentifierClient) CreateBulk(builders ...*PlayerIdentifierCreate) *PlayerIdentifierCreateBulk {
	return &PlayerIdentifierCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlayerIdentifier.
func (c *PlayerIdentifierClient) Update() *PlayerIdentifierUpdate {
	mutation := newPlayerIdentifierMutation(c.config, OpUpdate)
	return &PlayerIdentifierUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerIdentifierClient) UpdateOne(pi *PlayerIdentifier) *PlayerIdentifierUpdateOne {
	mutation := newPlayerIdentifierMutation(c.config, OpUpdateOne, withPlayerIdentifier(pi))
	return &PlayerIdentifierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerIdentifierClient) UpdateOneID(id int) *PlayerIdentifierUpdateOne {
	mutation := newPlayerIdentifierMutation(c.config, OpUpdateOne, withPlayerIdentifierID(id))
	return &PlayerIdentifierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlayerIdentifier.
func (c *PlayerIdentifierClient) Delete() *PlayerIdentifierDelete {
	mutation := newPlayerIdentifierMutation(c.config, OpDelete)
	return &PlayerIdentifierDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PlayerIdentifierClient) DeleteOne(pi *PlayerIdentifier) *PlayerIdentifierDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PlayerIdentifierClient) DeleteOneID(id int) *PlayerIdentifierDeleteOne {
	builder := c.Delete().Where(playeridentifier.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerIdentifierDeleteOne{builder}
}

// Query returns a query builder for PlayerIdentifier.
func (c *PlayerIdentifierClient) Query() *PlayerIdentifierQuery {
	return &PlayerIdentifierQuery{config: c.config}
}

// Get returns a PlayerIdentifier entity by its id.
func (c *PlayerIdentifierClient) Get(ctx context.Context, id int) (*PlayerIdentifier, error) {
	return c.Query().Where(playeridentifier.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerIdentifierClient) GetX(ctx context.Context, id int) *PlayerIdentifier {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a PlayerIdentifier.
func (c *PlayerIdentifierClient) QueryMetadata(pi *PlayerIdentifier) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playeridentifier.Table, playeridentifier.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, playeridentifier.MetadataTable, playeridentifier.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayer queries the player edge of a PlayerIdentifier.
func (c *PlayerIdentifierClient) QueryPlayer(pi *PlayerIdentifier) *PlayerQuery {
	query := &PlayerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playeridentifier.Table, playeridentifier.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, playeridentifier.PlayerTable, playeridentifier.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerIdentifierClient) Hooks() []Hook {
	return c.hooks.PlayerIdentifier
}

// ServerClient is a client for the Server schema.
type ServerClient struct {
	config
}

// NewServerClient returns a client for the Server from the given config.
func NewServerClient(c config) *ServerClient {
	return &ServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `server.Hooks(f(g(h())))`.
func (c *ServerClient) Use(hooks ...Hook) {
	c.hooks.Server = append(c.hooks.Server, hooks...)
}

// Create returns a create builder for Server.
func (c *ServerClient) Create() *ServerCreate {
	mutation := newServerMutation(c.config, OpCreate)
	return &ServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Server entities.
func (c *ServerClient) CreateBulk(builders ...*ServerCreate) *ServerCreateBulk {
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Server.
func (c *ServerClient) Update() *ServerUpdate {
	mutation := newServerMutation(c.config, OpUpdate)
	return &ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerClient) UpdateOne(s *Server) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServer(s))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerClient) UpdateOneID(id int) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServerID(id))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Server.
func (c *ServerClient) Delete() *ServerDelete {
	mutation := newServerMutation(c.config, OpDelete)
	return &ServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ServerClient) DeleteOne(s *Server) *ServerDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ServerClient) DeleteOneID(id int) *ServerDeleteOne {
	builder := c.Delete().Where(server.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerDeleteOne{builder}
}

// Query returns a query builder for Server.
func (c *ServerClient) Query() *ServerQuery {
	return &ServerQuery{config: c.config}
}

// Get returns a Server entity by its id.
func (c *ServerClient) Get(ctx context.Context, id int) (*Server, error) {
	return c.Query().Where(server.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerClient) GetX(ctx context.Context, id int) *Server {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a Server.
func (c *ServerClient) QueryMetadata(s *Server) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(server.Table, server.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, server.MetadataTable, server.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerType queries the server_type edge of a Server.
func (c *ServerClient) QueryServerType(s *Server) *ServerTypeQuery {
	query := &ServerTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(server.Table, server.FieldID, id),
			sqlgraph.To(servertype.Table, servertype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, server.ServerTypeTable, server.ServerTypeColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMapType queries the map_type edge of a Server.
func (c *ServerClient) QueryMapType(s *Server) *MapTypeQuery {
	query := &MapTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(server.Table, server.FieldID, id),
			sqlgraph.To(maptype.Table, maptype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, server.MapTypeTable, server.MapTypeColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayers queries the players edge of a Server.
func (c *ServerClient) QueryPlayers(s *Server) *PlayerQuery {
	query := &PlayerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(server.Table, server.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, server.PlayersTable, server.PlayersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServerClient) Hooks() []Hook {
	return c.hooks.Server
}

// ServerTypeClient is a client for the ServerType schema.
type ServerTypeClient struct {
	config
}

// NewServerTypeClient returns a client for the ServerType from the given config.
func NewServerTypeClient(c config) *ServerTypeClient {
	return &ServerTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servertype.Hooks(f(g(h())))`.
func (c *ServerTypeClient) Use(hooks ...Hook) {
	c.hooks.ServerType = append(c.hooks.ServerType, hooks...)
}

// Create returns a create builder for ServerType.
func (c *ServerTypeClient) Create() *ServerTypeCreate {
	mutation := newServerTypeMutation(c.config, OpCreate)
	return &ServerTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServerType entities.
func (c *ServerTypeClient) CreateBulk(builders ...*ServerTypeCreate) *ServerTypeCreateBulk {
	return &ServerTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServerType.
func (c *ServerTypeClient) Update() *ServerTypeUpdate {
	mutation := newServerTypeMutation(c.config, OpUpdate)
	return &ServerTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerTypeClient) UpdateOne(st *ServerType) *ServerTypeUpdateOne {
	mutation := newServerTypeMutation(c.config, OpUpdateOne, withServerType(st))
	return &ServerTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerTypeClient) UpdateOneID(id int) *ServerTypeUpdateOne {
	mutation := newServerTypeMutation(c.config, OpUpdateOne, withServerTypeID(id))
	return &ServerTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServerType.
func (c *ServerTypeClient) Delete() *ServerTypeDelete {
	mutation := newServerTypeMutation(c.config, OpDelete)
	return &ServerTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ServerTypeClient) DeleteOne(st *ServerType) *ServerTypeDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ServerTypeClient) DeleteOneID(id int) *ServerTypeDeleteOne {
	builder := c.Delete().Where(servertype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerTypeDeleteOne{builder}
}

// Query returns a query builder for ServerType.
func (c *ServerTypeClient) Query() *ServerTypeQuery {
	return &ServerTypeQuery{config: c.config}
}

// Get returns a ServerType entity by its id.
func (c *ServerTypeClient) Get(ctx context.Context, id int) (*ServerType, error) {
	return c.Query().Where(servertype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerTypeClient) GetX(ctx context.Context, id int) *ServerType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServers queries the servers edge of a ServerType.
func (c *ServerTypeClient) QueryServers(st *ServerType) *ServerQuery {
	query := &ServerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertype.Table, servertype.FieldID, id),
			sqlgraph.To(server.Table, server.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, servertype.ServersTable, servertype.ServersColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServerTypeClient) Hooks() []Hook {
	return c.hooks.ServerType
}

// SessionTokenClient is a client for the SessionToken schema.
type SessionTokenClient struct {
	config
}

// NewSessionTokenClient returns a client for the SessionToken from the given config.
func NewSessionTokenClient(c config) *SessionTokenClient {
	return &SessionTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sessiontoken.Hooks(f(g(h())))`.
func (c *SessionTokenClient) Use(hooks ...Hook) {
	c.hooks.SessionToken = append(c.hooks.SessionToken, hooks...)
}

// Create returns a create builder for SessionToken.
func (c *SessionTokenClient) Create() *SessionTokenCreate {
	mutation := newSessionTokenMutation(c.config, OpCreate)
	return &SessionTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SessionToken entities.
func (c *SessionTokenClient) CreateBulk(builders ...*SessionTokenCreate) *SessionTokenCreateBulk {
	return &SessionTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SessionToken.
func (c *SessionTokenClient) Update() *SessionTokenUpdate {
	mutation := newSessionTokenMutation(c.config, OpUpdate)
	return &SessionTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionTokenClient) UpdateOne(st *SessionToken) *SessionTokenUpdateOne {
	mutation := newSessionTokenMutation(c.config, OpUpdateOne, withSessionToken(st))
	return &SessionTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionTokenClient) UpdateOneID(id int) *SessionTokenUpdateOne {
	mutation := newSessionTokenMutation(c.config, OpUpdateOne, withSessionTokenID(id))
	return &SessionTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SessionToken.
func (c *SessionTokenClient) Delete() *SessionTokenDelete {
	mutation := newSessionTokenMutation(c.config, OpDelete)
	return &SessionTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SessionTokenClient) DeleteOne(st *SessionToken) *SessionTokenDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SessionTokenClient) DeleteOneID(id int) *SessionTokenDeleteOne {
	builder := c.Delete().Where(sessiontoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionTokenDeleteOne{builder}
}

// Query returns a query builder for SessionToken.
func (c *SessionTokenClient) Query() *SessionTokenQuery {
	return &SessionTokenQuery{config: c.config}
}

// Get returns a SessionToken entity by its id.
func (c *SessionTokenClient) Get(ctx context.Context, id int) (*SessionToken, error) {
	return c.Query().Where(sessiontoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionTokenClient) GetX(ctx context.Context, id int) *SessionToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SessionToken.
func (c *SessionTokenClient) QueryUser(st *SessionToken) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessiontoken.Table, sessiontoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sessiontoken.UserTable, sessiontoken.UserColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionTokenClient) Hooks() []Hook {
	return c.hooks.SessionToken
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetadata queries the metadata edge of a User.
func (c *UserClient) QueryMetadata(u *User) *MetadataQuery {
	query := &MetadataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(metadata.Table, metadata.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.MetadataTable, user.MetadataColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessionTokens queries the session_tokens edge of a User.
func (c *UserClient) QuerySessionTokens(u *User) *SessionTokenQuery {
	query := &SessionTokenQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(sessiontoken.Table, sessiontoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionTokensTable, user.SessionTokensColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivation queries the activation edge of a User.
func (c *UserClient) QueryActivation(u *User) *ActivationQuery {
	query := &ActivationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(activation.Table, activation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.ActivationTable, user.ActivationColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivations queries the activations edge of a User.
func (c *UserClient) QueryActivations(u *User) *ActivationQuery {
	query := &ActivationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(activation.Table, activation.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.ActivationsTable, user.ActivationsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayers queries the players edge of a User.
func (c *UserClient) QueryPlayers(u *User) *PlayerQuery {
	query := &PlayerQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.PlayersTable, user.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
