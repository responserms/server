// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/responserms/server/ent/activation"
	"github.com/responserms/server/ent/maplayer"
	"github.com/responserms/server/ent/maptype"
	"github.com/responserms/server/ent/metadata"
	"github.com/responserms/server/ent/player"
	"github.com/responserms/server/ent/playeridentifier"
	"github.com/responserms/server/ent/predicate"
	"github.com/responserms/server/ent/server"
	"github.com/responserms/server/ent/servertype"
	"github.com/responserms/server/ent/session"
	"github.com/responserms/server/ent/token"
	"github.com/responserms/server/ent/user"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivation       = "Activation"
	TypeAuthSession      = "AuthSession"
	TypeMapLayer         = "MapLayer"
	TypeMapType          = "MapType"
	TypeMetadata         = "Metadata"
	TypePlayer           = "Player"
	TypePlayerIdentifier = "PlayerIdentifier"
	TypeServer           = "Server"
	TypeServerType       = "ServerType"
	TypeSession          = "Session"
	TypeToken            = "Token"
	TypeUser             = "User"
)

// ActivationMutation represents an operation that mutate the Activations
// nodes in the graph.
type ActivationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	internal_comments *string
	comments          *string
	clearedFields     map[string]struct{}
	user              map[int]struct{}
	removeduser       map[int]struct{}
	cleareduser       bool
	actor             map[int]struct{}
	removedactor      map[int]struct{}
	clearedactor      bool
	done              bool
	oldValue          func(context.Context) (*Activation, error)
	predicates        []predicate.Activation
}

var _ ent.Mutation = (*ActivationMutation)(nil)

// activationOption allows to manage the mutation configuration using functional options.
type activationOption func(*ActivationMutation)

// newActivationMutation creates new mutation for Activation.
func newActivationMutation(c config, op Op, opts ...activationOption) *ActivationMutation {
	m := &ActivationMutation{
		config:        c,
		op:            op,
		typ:           TypeActivation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivationID sets the id field of the mutation.
func withActivationID(id int) activationOption {
	return func(m *ActivationMutation) {
		var (
			err   error
			once  sync.Once
			value *Activation
		)
		m.oldValue = func(ctx context.Context) (*Activation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivation sets the old Activation of the mutation.
func withActivation(node *Activation) activationOption {
	return func(m *ActivationMutation) {
		m.oldValue = func(context.Context) (*Activation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ActivationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ActivationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ActivationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Activation.
// If the Activation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ActivationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ActivationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ActivationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Activation.
// If the Activation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ActivationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInternalComments sets the internal_comments field.
func (m *ActivationMutation) SetInternalComments(s string) {
	m.internal_comments = &s
}

// InternalComments returns the internal_comments value in the mutation.
func (m *ActivationMutation) InternalComments() (r string, exists bool) {
	v := m.internal_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalComments returns the old internal_comments value of the Activation.
// If the Activation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivationMutation) OldInternalComments(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalComments is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalComments: %w", err)
	}
	return oldValue.InternalComments, nil
}

// ClearInternalComments clears the value of internal_comments.
func (m *ActivationMutation) ClearInternalComments() {
	m.internal_comments = nil
	m.clearedFields[activation.FieldInternalComments] = struct{}{}
}

// InternalCommentsCleared returns if the field internal_comments was cleared in this mutation.
func (m *ActivationMutation) InternalCommentsCleared() bool {
	_, ok := m.clearedFields[activation.FieldInternalComments]
	return ok
}

// ResetInternalComments reset all changes of the "internal_comments" field.
func (m *ActivationMutation) ResetInternalComments() {
	m.internal_comments = nil
	delete(m.clearedFields, activation.FieldInternalComments)
}

// SetComments sets the comments field.
func (m *ActivationMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the comments value in the mutation.
func (m *ActivationMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old comments value of the Activation.
// If the Activation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ActivationMutation) OldComments(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of comments.
func (m *ActivationMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[activation.FieldComments] = struct{}{}
}

// CommentsCleared returns if the field comments was cleared in this mutation.
func (m *ActivationMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[activation.FieldComments]
	return ok
}

// ResetComments reset all changes of the "comments" field.
func (m *ActivationMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, activation.FieldComments)
}

// AddUserIDs adds the user edge to User by ids.
func (m *ActivationMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the user edge to User.
func (m *ActivationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *ActivationMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the user edge to User by ids.
func (m *ActivationMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed ids of user.
func (m *ActivationMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the user ids in the mutation.
func (m *ActivationMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *ActivationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddActorIDs adds the actor edge to User by ids.
func (m *ActivationMutation) AddActorIDs(ids ...int) {
	if m.actor == nil {
		m.actor = make(map[int]struct{})
	}
	for i := range ids {
		m.actor[ids[i]] = struct{}{}
	}
}

// ClearActor clears the actor edge to User.
func (m *ActivationMutation) ClearActor() {
	m.clearedactor = true
}

// ActorCleared returns if the edge actor was cleared.
func (m *ActivationMutation) ActorCleared() bool {
	return m.clearedactor
}

// RemoveActorIDs removes the actor edge to User by ids.
func (m *ActivationMutation) RemoveActorIDs(ids ...int) {
	if m.removedactor == nil {
		m.removedactor = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactor[ids[i]] = struct{}{}
	}
}

// RemovedActor returns the removed ids of actor.
func (m *ActivationMutation) RemovedActorIDs() (ids []int) {
	for id := range m.removedactor {
		ids = append(ids, id)
	}
	return
}

// ActorIDs returns the actor ids in the mutation.
func (m *ActivationMutation) ActorIDs() (ids []int) {
	for id := range m.actor {
		ids = append(ids, id)
	}
	return
}

// ResetActor reset all changes of the "actor" edge.
func (m *ActivationMutation) ResetActor() {
	m.actor = nil
	m.clearedactor = false
	m.removedactor = nil
}

// Op returns the operation name.
func (m *ActivationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activation).
func (m *ActivationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ActivationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, activation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activation.FieldUpdatedAt)
	}
	if m.internal_comments != nil {
		fields = append(fields, activation.FieldInternalComments)
	}
	if m.comments != nil {
		fields = append(fields, activation.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ActivationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activation.FieldCreatedAt:
		return m.CreatedAt()
	case activation.FieldUpdatedAt:
		return m.UpdatedAt()
	case activation.FieldInternalComments:
		return m.InternalComments()
	case activation.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ActivationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activation.FieldInternalComments:
		return m.OldInternalComments(ctx)
	case activation.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown Activation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activation.FieldInternalComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalComments(v)
		return nil
	case activation.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown Activation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ActivationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ActivationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ActivationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Activation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ActivationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activation.FieldInternalComments) {
		fields = append(fields, activation.FieldInternalComments)
	}
	if m.FieldCleared(activation.FieldComments) {
		fields = append(fields, activation.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ActivationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivationMutation) ClearField(name string) error {
	switch name {
	case activation.FieldInternalComments:
		m.ClearInternalComments()
		return nil
	case activation.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown Activation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ActivationMutation) ResetField(name string) error {
	switch name {
	case activation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activation.FieldInternalComments:
		m.ResetInternalComments()
		return nil
	case activation.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown Activation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ActivationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, activation.EdgeUser)
	}
	if m.actor != nil {
		edges = append(edges, activation.EdgeActor)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ActivationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activation.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case activation.EdgeActor:
		ids := make([]ent.Value, 0, len(m.actor))
		for id := range m.actor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ActivationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, activation.EdgeUser)
	}
	if m.removedactor != nil {
		edges = append(edges, activation.EdgeActor)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ActivationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activation.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case activation.EdgeActor:
		ids := make([]ent.Value, 0, len(m.removedactor))
		for id := range m.removedactor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ActivationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, activation.EdgeUser)
	}
	if m.clearedactor {
		edges = append(edges, activation.EdgeActor)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ActivationMutation) EdgeCleared(name string) bool {
	switch name {
	case activation.EdgeUser:
		return m.cleareduser
	case activation.EdgeActor:
		return m.clearedactor
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ActivationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Activation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ActivationMutation) ResetEdge(name string) error {
	switch name {
	case activation.EdgeUser:
		m.ResetUser()
		return nil
	case activation.EdgeActor:
		m.ResetActor()
		return nil
	}
	return fmt.Errorf("unknown Activation edge %s", name)
}

// AuthSessionMutation represents an operation that mutate the AuthSessions
// nodes in the graph.
type AuthSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthSession, error)
	predicates    []predicate.AuthSession
}

var _ ent.Mutation = (*AuthSessionMutation)(nil)

// authsessionOption allows to manage the mutation configuration using functional options.
type authsessionOption func(*AuthSessionMutation)

// newAuthSessionMutation creates new mutation for AuthSession.
func newAuthSessionMutation(c config, op Op, opts ...authsessionOption) *AuthSessionMutation {
	m := &AuthSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthSessionID sets the id field of the mutation.
func withAuthSessionID(id int) authsessionOption {
	return func(m *AuthSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthSession
		)
		m.oldValue = func(ctx context.Context) (*AuthSession, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthSession sets the old AuthSession of the mutation.
func withAuthSession(node *AuthSession) authsessionOption {
	return func(m *AuthSessionMutation) {
		m.oldValue = func(context.Context) (*AuthSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AuthSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *AuthSessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthSession).
func (m *AuthSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AuthSessionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AuthSessionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AuthSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AuthSession field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AuthSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AuthSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AuthSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AuthSessionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AuthSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AuthSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AuthSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthSession nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AuthSessionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AuthSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AuthSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AuthSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AuthSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AuthSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AuthSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AuthSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AuthSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthSession unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AuthSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthSession edge %s", name)
}

// MapLayerMutation represents an operation that mutate the MapLayers
// nodes in the graph.
type MapLayerMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	url_template    *string
	is_public       *bool
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	map_type        *int
	clearedmap_type bool
	done            bool
	oldValue        func(context.Context) (*MapLayer, error)
	predicates      []predicate.MapLayer
}

var _ ent.Mutation = (*MapLayerMutation)(nil)

// maplayerOption allows to manage the mutation configuration using functional options.
type maplayerOption func(*MapLayerMutation)

// newMapLayerMutation creates new mutation for MapLayer.
func newMapLayerMutation(c config, op Op, opts ...maplayerOption) *MapLayerMutation {
	m := &MapLayerMutation{
		config:        c,
		op:            op,
		typ:           TypeMapLayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMapLayerID sets the id field of the mutation.
func withMapLayerID(id int) maplayerOption {
	return func(m *MapLayerMutation) {
		var (
			err   error
			once  sync.Once
			value *MapLayer
		)
		m.oldValue = func(ctx context.Context) (*MapLayer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MapLayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMapLayer sets the old MapLayer of the mutation.
func withMapLayer(node *MapLayer) maplayerOption {
	return func(m *MapLayerMutation) {
		m.oldValue = func(context.Context) (*MapLayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MapLayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MapLayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MapLayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *MapLayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MapLayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the MapLayer.
// If the MapLayer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapLayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MapLayerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MapLayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MapLayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the MapLayer.
// If the MapLayer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapLayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MapLayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *MapLayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MapLayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MapLayer.
// If the MapLayer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapLayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MapLayerMutation) ResetName() {
	m.name = nil
}

// SetURLTemplate sets the url_template field.
func (m *MapLayerMutation) SetURLTemplate(s string) {
	m.url_template = &s
}

// URLTemplate returns the url_template value in the mutation.
func (m *MapLayerMutation) URLTemplate() (r string, exists bool) {
	v := m.url_template
	if v == nil {
		return
	}
	return *v, true
}

// OldURLTemplate returns the old url_template value of the MapLayer.
// If the MapLayer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapLayerMutation) OldURLTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldURLTemplate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldURLTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLTemplate: %w", err)
	}
	return oldValue.URLTemplate, nil
}

// ResetURLTemplate reset all changes of the "url_template" field.
func (m *MapLayerMutation) ResetURLTemplate() {
	m.url_template = nil
}

// SetIsPublic sets the is_public field.
func (m *MapLayerMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the is_public value in the mutation.
func (m *MapLayerMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old is_public value of the MapLayer.
// If the MapLayer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapLayerMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsPublic is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic reset all changes of the "is_public" field.
func (m *MapLayerMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetMetadataID sets the metadata edge to Metadata by id.
func (m *MapLayerMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the metadata edge to Metadata.
func (m *MapLayerMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared returns if the edge metadata was cleared.
func (m *MapLayerMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the metadata id in the mutation.
func (m *MapLayerMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the metadata ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *MapLayerMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata reset all changes of the "metadata" edge.
func (m *MapLayerMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// SetMapTypeID sets the map_type edge to MapType by id.
func (m *MapLayerMutation) SetMapTypeID(id int) {
	m.map_type = &id
}

// ClearMapType clears the map_type edge to MapType.
func (m *MapLayerMutation) ClearMapType() {
	m.clearedmap_type = true
}

// MapTypeCleared returns if the edge map_type was cleared.
func (m *MapLayerMutation) MapTypeCleared() bool {
	return m.clearedmap_type
}

// MapTypeID returns the map_type id in the mutation.
func (m *MapLayerMutation) MapTypeID() (id int, exists bool) {
	if m.map_type != nil {
		return *m.map_type, true
	}
	return
}

// MapTypeIDs returns the map_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MapTypeID instead. It exists only for internal usage by the builders.
func (m *MapLayerMutation) MapTypeIDs() (ids []int) {
	if id := m.map_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMapType reset all changes of the "map_type" edge.
func (m *MapLayerMutation) ResetMapType() {
	m.map_type = nil
	m.clearedmap_type = false
}

// Op returns the operation name.
func (m *MapLayerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MapLayer).
func (m *MapLayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MapLayerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, maplayer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, maplayer.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, maplayer.FieldName)
	}
	if m.url_template != nil {
		fields = append(fields, maplayer.FieldURLTemplate)
	}
	if m.is_public != nil {
		fields = append(fields, maplayer.FieldIsPublic)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MapLayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maplayer.FieldCreatedAt:
		return m.CreatedAt()
	case maplayer.FieldUpdatedAt:
		return m.UpdatedAt()
	case maplayer.FieldName:
		return m.Name()
	case maplayer.FieldURLTemplate:
		return m.URLTemplate()
	case maplayer.FieldIsPublic:
		return m.IsPublic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MapLayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maplayer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case maplayer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case maplayer.FieldName:
		return m.OldName(ctx)
	case maplayer.FieldURLTemplate:
		return m.OldURLTemplate(ctx)
	case maplayer.FieldIsPublic:
		return m.OldIsPublic(ctx)
	}
	return nil, fmt.Errorf("unknown MapLayer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MapLayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maplayer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case maplayer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case maplayer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case maplayer.FieldURLTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLTemplate(v)
		return nil
	case maplayer.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	}
	return fmt.Errorf("unknown MapLayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MapLayerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MapLayerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MapLayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MapLayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MapLayerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MapLayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MapLayerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MapLayer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MapLayerMutation) ResetField(name string) error {
	switch name {
	case maplayer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case maplayer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case maplayer.FieldName:
		m.ResetName()
		return nil
	case maplayer.FieldURLTemplate:
		m.ResetURLTemplate()
		return nil
	case maplayer.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	}
	return fmt.Errorf("unknown MapLayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MapLayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, maplayer.EdgeMetadata)
	}
	if m.map_type != nil {
		edges = append(edges, maplayer.EdgeMapType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MapLayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case maplayer.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case maplayer.EdgeMapType:
		if id := m.map_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MapLayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MapLayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MapLayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, maplayer.EdgeMetadata)
	}
	if m.clearedmap_type {
		edges = append(edges, maplayer.EdgeMapType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MapLayerMutation) EdgeCleared(name string) bool {
	switch name {
	case maplayer.EdgeMetadata:
		return m.clearedmetadata
	case maplayer.EdgeMapType:
		return m.clearedmap_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MapLayerMutation) ClearEdge(name string) error {
	switch name {
	case maplayer.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case maplayer.EdgeMapType:
		m.ClearMapType()
		return nil
	}
	return fmt.Errorf("unknown MapLayer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MapLayerMutation) ResetEdge(name string) error {
	switch name {
	case maplayer.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case maplayer.EdgeMapType:
		m.ResetMapType()
		return nil
	}
	return fmt.Errorf("unknown MapLayer edge %s", name)
}

// MapTypeMutation represents an operation that mutate the MapTypes
// nodes in the graph.
type MapTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	min_zoom          *int
	addmin_zoom       *int
	max_zoom          *int
	addmax_zoom       *int
	min_x             *float64
	addmin_x          *float64
	min_y             *float64
	addmin_y          *float64
	max_x             *float64
	addmax_x          *float64
	max_y             *float64
	addmax_y          *float64
	clearedFields     map[string]struct{}
	metadata          *int
	clearedmetadata   bool
	map_layers        map[int]struct{}
	removedmap_layers map[int]struct{}
	clearedmap_layers bool
	servers           map[int]struct{}
	removedservers    map[int]struct{}
	clearedservers    bool
	done              bool
	oldValue          func(context.Context) (*MapType, error)
	predicates        []predicate.MapType
}

var _ ent.Mutation = (*MapTypeMutation)(nil)

// maptypeOption allows to manage the mutation configuration using functional options.
type maptypeOption func(*MapTypeMutation)

// newMapTypeMutation creates new mutation for MapType.
func newMapTypeMutation(c config, op Op, opts ...maptypeOption) *MapTypeMutation {
	m := &MapTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMapType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMapTypeID sets the id field of the mutation.
func withMapTypeID(id int) maptypeOption {
	return func(m *MapTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MapType
		)
		m.oldValue = func(ctx context.Context) (*MapType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MapType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMapType sets the old MapType of the mutation.
func withMapType(node *MapType) maptypeOption {
	return func(m *MapTypeMutation) {
		m.oldValue = func(context.Context) (*MapType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MapTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MapTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MapTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *MapTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MapTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MapTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MapTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MapTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MapTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *MapTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MapTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MapTypeMutation) ResetName() {
	m.name = nil
}

// SetMinZoom sets the min_zoom field.
func (m *MapTypeMutation) SetMinZoom(i int) {
	m.min_zoom = &i
	m.addmin_zoom = nil
}

// MinZoom returns the min_zoom value in the mutation.
func (m *MapTypeMutation) MinZoom() (r int, exists bool) {
	v := m.min_zoom
	if v == nil {
		return
	}
	return *v, true
}

// OldMinZoom returns the old min_zoom value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldMinZoom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinZoom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinZoom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinZoom: %w", err)
	}
	return oldValue.MinZoom, nil
}

// AddMinZoom adds i to min_zoom.
func (m *MapTypeMutation) AddMinZoom(i int) {
	if m.addmin_zoom != nil {
		*m.addmin_zoom += i
	} else {
		m.addmin_zoom = &i
	}
}

// AddedMinZoom returns the value that was added to the min_zoom field in this mutation.
func (m *MapTypeMutation) AddedMinZoom() (r int, exists bool) {
	v := m.addmin_zoom
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinZoom reset all changes of the "min_zoom" field.
func (m *MapTypeMutation) ResetMinZoom() {
	m.min_zoom = nil
	m.addmin_zoom = nil
}

// SetMaxZoom sets the max_zoom field.
func (m *MapTypeMutation) SetMaxZoom(i int) {
	m.max_zoom = &i
	m.addmax_zoom = nil
}

// MaxZoom returns the max_zoom value in the mutation.
func (m *MapTypeMutation) MaxZoom() (r int, exists bool) {
	v := m.max_zoom
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxZoom returns the old max_zoom value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldMaxZoom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxZoom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxZoom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxZoom: %w", err)
	}
	return oldValue.MaxZoom, nil
}

// AddMaxZoom adds i to max_zoom.
func (m *MapTypeMutation) AddMaxZoom(i int) {
	if m.addmax_zoom != nil {
		*m.addmax_zoom += i
	} else {
		m.addmax_zoom = &i
	}
}

// AddedMaxZoom returns the value that was added to the max_zoom field in this mutation.
func (m *MapTypeMutation) AddedMaxZoom() (r int, exists bool) {
	v := m.addmax_zoom
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxZoom reset all changes of the "max_zoom" field.
func (m *MapTypeMutation) ResetMaxZoom() {
	m.max_zoom = nil
	m.addmax_zoom = nil
}

// SetMinX sets the min_x field.
func (m *MapTypeMutation) SetMinX(f float64) {
	m.min_x = &f
	m.addmin_x = nil
}

// MinX returns the min_x value in the mutation.
func (m *MapTypeMutation) MinX() (r float64, exists bool) {
	v := m.min_x
	if v == nil {
		return
	}
	return *v, true
}

// OldMinX returns the old min_x value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldMinX(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinX is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinX: %w", err)
	}
	return oldValue.MinX, nil
}

// AddMinX adds f to min_x.
func (m *MapTypeMutation) AddMinX(f float64) {
	if m.addmin_x != nil {
		*m.addmin_x += f
	} else {
		m.addmin_x = &f
	}
}

// AddedMinX returns the value that was added to the min_x field in this mutation.
func (m *MapTypeMutation) AddedMinX() (r float64, exists bool) {
	v := m.addmin_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinX reset all changes of the "min_x" field.
func (m *MapTypeMutation) ResetMinX() {
	m.min_x = nil
	m.addmin_x = nil
}

// SetMinY sets the min_y field.
func (m *MapTypeMutation) SetMinY(f float64) {
	m.min_y = &f
	m.addmin_y = nil
}

// MinY returns the min_y value in the mutation.
func (m *MapTypeMutation) MinY() (r float64, exists bool) {
	v := m.min_y
	if v == nil {
		return
	}
	return *v, true
}

// OldMinY returns the old min_y value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldMinY(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinY: %w", err)
	}
	return oldValue.MinY, nil
}

// AddMinY adds f to min_y.
func (m *MapTypeMutation) AddMinY(f float64) {
	if m.addmin_y != nil {
		*m.addmin_y += f
	} else {
		m.addmin_y = &f
	}
}

// AddedMinY returns the value that was added to the min_y field in this mutation.
func (m *MapTypeMutation) AddedMinY() (r float64, exists bool) {
	v := m.addmin_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinY reset all changes of the "min_y" field.
func (m *MapTypeMutation) ResetMinY() {
	m.min_y = nil
	m.addmin_y = nil
}

// SetMaxX sets the max_x field.
func (m *MapTypeMutation) SetMaxX(f float64) {
	m.max_x = &f
	m.addmax_x = nil
}

// MaxX returns the max_x value in the mutation.
func (m *MapTypeMutation) MaxX() (r float64, exists bool) {
	v := m.max_x
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxX returns the old max_x value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldMaxX(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxX is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxX: %w", err)
	}
	return oldValue.MaxX, nil
}

// AddMaxX adds f to max_x.
func (m *MapTypeMutation) AddMaxX(f float64) {
	if m.addmax_x != nil {
		*m.addmax_x += f
	} else {
		m.addmax_x = &f
	}
}

// AddedMaxX returns the value that was added to the max_x field in this mutation.
func (m *MapTypeMutation) AddedMaxX() (r float64, exists bool) {
	v := m.addmax_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxX reset all changes of the "max_x" field.
func (m *MapTypeMutation) ResetMaxX() {
	m.max_x = nil
	m.addmax_x = nil
}

// SetMaxY sets the max_y field.
func (m *MapTypeMutation) SetMaxY(f float64) {
	m.max_y = &f
	m.addmax_y = nil
}

// MaxY returns the max_y value in the mutation.
func (m *MapTypeMutation) MaxY() (r float64, exists bool) {
	v := m.max_y
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxY returns the old max_y value of the MapType.
// If the MapType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MapTypeMutation) OldMaxY(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxY is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxY: %w", err)
	}
	return oldValue.MaxY, nil
}

// AddMaxY adds f to max_y.
func (m *MapTypeMutation) AddMaxY(f float64) {
	if m.addmax_y != nil {
		*m.addmax_y += f
	} else {
		m.addmax_y = &f
	}
}

// AddedMaxY returns the value that was added to the max_y field in this mutation.
func (m *MapTypeMutation) AddedMaxY() (r float64, exists bool) {
	v := m.addmax_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxY reset all changes of the "max_y" field.
func (m *MapTypeMutation) ResetMaxY() {
	m.max_y = nil
	m.addmax_y = nil
}

// SetMetadataID sets the metadata edge to Metadata by id.
func (m *MapTypeMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the metadata edge to Metadata.
func (m *MapTypeMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared returns if the edge metadata was cleared.
func (m *MapTypeMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the metadata id in the mutation.
func (m *MapTypeMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the metadata ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *MapTypeMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata reset all changes of the "metadata" edge.
func (m *MapTypeMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddMapLayerIDs adds the map_layers edge to MapLayer by ids.
func (m *MapTypeMutation) AddMapLayerIDs(ids ...int) {
	if m.map_layers == nil {
		m.map_layers = make(map[int]struct{})
	}
	for i := range ids {
		m.map_layers[ids[i]] = struct{}{}
	}
}

// ClearMapLayers clears the map_layers edge to MapLayer.
func (m *MapTypeMutation) ClearMapLayers() {
	m.clearedmap_layers = true
}

// MapLayersCleared returns if the edge map_layers was cleared.
func (m *MapTypeMutation) MapLayersCleared() bool {
	return m.clearedmap_layers
}

// RemoveMapLayerIDs removes the map_layers edge to MapLayer by ids.
func (m *MapTypeMutation) RemoveMapLayerIDs(ids ...int) {
	if m.removedmap_layers == nil {
		m.removedmap_layers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmap_layers[ids[i]] = struct{}{}
	}
}

// RemovedMapLayers returns the removed ids of map_layers.
func (m *MapTypeMutation) RemovedMapLayersIDs() (ids []int) {
	for id := range m.removedmap_layers {
		ids = append(ids, id)
	}
	return
}

// MapLayersIDs returns the map_layers ids in the mutation.
func (m *MapTypeMutation) MapLayersIDs() (ids []int) {
	for id := range m.map_layers {
		ids = append(ids, id)
	}
	return
}

// ResetMapLayers reset all changes of the "map_layers" edge.
func (m *MapTypeMutation) ResetMapLayers() {
	m.map_layers = nil
	m.clearedmap_layers = false
	m.removedmap_layers = nil
}

// AddServerIDs adds the servers edge to Server by ids.
func (m *MapTypeMutation) AddServerIDs(ids ...int) {
	if m.servers == nil {
		m.servers = make(map[int]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the servers edge to Server.
func (m *MapTypeMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared returns if the edge servers was cleared.
func (m *MapTypeMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the servers edge to Server by ids.
func (m *MapTypeMutation) RemoveServerIDs(ids ...int) {
	if m.removedservers == nil {
		m.removedservers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed ids of servers.
func (m *MapTypeMutation) RemovedServersIDs() (ids []int) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the servers ids in the mutation.
func (m *MapTypeMutation) ServersIDs() (ids []int) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers reset all changes of the "servers" edge.
func (m *MapTypeMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// Op returns the operation name.
func (m *MapTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MapType).
func (m *MapTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MapTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, maptype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, maptype.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, maptype.FieldName)
	}
	if m.min_zoom != nil {
		fields = append(fields, maptype.FieldMinZoom)
	}
	if m.max_zoom != nil {
		fields = append(fields, maptype.FieldMaxZoom)
	}
	if m.min_x != nil {
		fields = append(fields, maptype.FieldMinX)
	}
	if m.min_y != nil {
		fields = append(fields, maptype.FieldMinY)
	}
	if m.max_x != nil {
		fields = append(fields, maptype.FieldMaxX)
	}
	if m.max_y != nil {
		fields = append(fields, maptype.FieldMaxY)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MapTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maptype.FieldCreatedAt:
		return m.CreatedAt()
	case maptype.FieldUpdatedAt:
		return m.UpdatedAt()
	case maptype.FieldName:
		return m.Name()
	case maptype.FieldMinZoom:
		return m.MinZoom()
	case maptype.FieldMaxZoom:
		return m.MaxZoom()
	case maptype.FieldMinX:
		return m.MinX()
	case maptype.FieldMinY:
		return m.MinY()
	case maptype.FieldMaxX:
		return m.MaxX()
	case maptype.FieldMaxY:
		return m.MaxY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MapTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maptype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case maptype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case maptype.FieldName:
		return m.OldName(ctx)
	case maptype.FieldMinZoom:
		return m.OldMinZoom(ctx)
	case maptype.FieldMaxZoom:
		return m.OldMaxZoom(ctx)
	case maptype.FieldMinX:
		return m.OldMinX(ctx)
	case maptype.FieldMinY:
		return m.OldMinY(ctx)
	case maptype.FieldMaxX:
		return m.OldMaxX(ctx)
	case maptype.FieldMaxY:
		return m.OldMaxY(ctx)
	}
	return nil, fmt.Errorf("unknown MapType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MapTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maptype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case maptype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case maptype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case maptype.FieldMinZoom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinZoom(v)
		return nil
	case maptype.FieldMaxZoom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxZoom(v)
		return nil
	case maptype.FieldMinX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinX(v)
		return nil
	case maptype.FieldMinY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinY(v)
		return nil
	case maptype.FieldMaxX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxX(v)
		return nil
	case maptype.FieldMaxY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxY(v)
		return nil
	}
	return fmt.Errorf("unknown MapType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MapTypeMutation) AddedFields() []string {
	var fields []string
	if m.addmin_zoom != nil {
		fields = append(fields, maptype.FieldMinZoom)
	}
	if m.addmax_zoom != nil {
		fields = append(fields, maptype.FieldMaxZoom)
	}
	if m.addmin_x != nil {
		fields = append(fields, maptype.FieldMinX)
	}
	if m.addmin_y != nil {
		fields = append(fields, maptype.FieldMinY)
	}
	if m.addmax_x != nil {
		fields = append(fields, maptype.FieldMaxX)
	}
	if m.addmax_y != nil {
		fields = append(fields, maptype.FieldMaxY)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MapTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case maptype.FieldMinZoom:
		return m.AddedMinZoom()
	case maptype.FieldMaxZoom:
		return m.AddedMaxZoom()
	case maptype.FieldMinX:
		return m.AddedMinX()
	case maptype.FieldMinY:
		return m.AddedMinY()
	case maptype.FieldMaxX:
		return m.AddedMaxX()
	case maptype.FieldMaxY:
		return m.AddedMaxY()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MapTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case maptype.FieldMinZoom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinZoom(v)
		return nil
	case maptype.FieldMaxZoom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxZoom(v)
		return nil
	case maptype.FieldMinX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinX(v)
		return nil
	case maptype.FieldMinY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinY(v)
		return nil
	case maptype.FieldMaxX:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxX(v)
		return nil
	case maptype.FieldMaxY:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxY(v)
		return nil
	}
	return fmt.Errorf("unknown MapType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MapTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MapTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MapTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MapType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MapTypeMutation) ResetField(name string) error {
	switch name {
	case maptype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case maptype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case maptype.FieldName:
		m.ResetName()
		return nil
	case maptype.FieldMinZoom:
		m.ResetMinZoom()
		return nil
	case maptype.FieldMaxZoom:
		m.ResetMaxZoom()
		return nil
	case maptype.FieldMinX:
		m.ResetMinX()
		return nil
	case maptype.FieldMinY:
		m.ResetMinY()
		return nil
	case maptype.FieldMaxX:
		m.ResetMaxX()
		return nil
	case maptype.FieldMaxY:
		m.ResetMaxY()
		return nil
	}
	return fmt.Errorf("unknown MapType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MapTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.metadata != nil {
		edges = append(edges, maptype.EdgeMetadata)
	}
	if m.map_layers != nil {
		edges = append(edges, maptype.EdgeMapLayers)
	}
	if m.servers != nil {
		edges = append(edges, maptype.EdgeServers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MapTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case maptype.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case maptype.EdgeMapLayers:
		ids := make([]ent.Value, 0, len(m.map_layers))
		for id := range m.map_layers {
			ids = append(ids, id)
		}
		return ids
	case maptype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MapTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmap_layers != nil {
		edges = append(edges, maptype.EdgeMapLayers)
	}
	if m.removedservers != nil {
		edges = append(edges, maptype.EdgeServers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MapTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case maptype.EdgeMapLayers:
		ids := make([]ent.Value, 0, len(m.removedmap_layers))
		for id := range m.removedmap_layers {
			ids = append(ids, id)
		}
		return ids
	case maptype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MapTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmetadata {
		edges = append(edges, maptype.EdgeMetadata)
	}
	if m.clearedmap_layers {
		edges = append(edges, maptype.EdgeMapLayers)
	}
	if m.clearedservers {
		edges = append(edges, maptype.EdgeServers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MapTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case maptype.EdgeMetadata:
		return m.clearedmetadata
	case maptype.EdgeMapLayers:
		return m.clearedmap_layers
	case maptype.EdgeServers:
		return m.clearedservers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MapTypeMutation) ClearEdge(name string) error {
	switch name {
	case maptype.EdgeMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown MapType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MapTypeMutation) ResetEdge(name string) error {
	switch name {
	case maptype.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case maptype.EdgeMapLayers:
		m.ResetMapLayers()
		return nil
	case maptype.EdgeServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown MapType edge %s", name)
}

// MetadataMutation represents an operation that mutate the MetadataSlice
// nodes in the graph.
type MetadataMutation struct {
	config
	op              Op
	typ             string
	id              *int
	data            *map[string]interface{}
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	map_type        *int
	clearedmap_type bool
	done            bool
	oldValue        func(context.Context) (*Metadata, error)
	predicates      []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows to manage the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for Metadata.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the id field of the mutation.
func withMetadataID(id int) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetData sets the data field.
func (m *MetadataMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the data value in the mutation.
func (m *MetadataMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old data value of the Metadata.
// If the Metadata object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MetadataMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData reset all changes of the "data" field.
func (m *MetadataMutation) ResetData() {
	m.data = nil
}

// SetUserID sets the user edge to User by id.
func (m *MetadataMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *MetadataMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *MetadataMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *MetadataMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *MetadataMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetMapTypeID sets the map_type edge to MapType by id.
func (m *MetadataMutation) SetMapTypeID(id int) {
	m.map_type = &id
}

// ClearMapType clears the map_type edge to MapType.
func (m *MetadataMutation) ClearMapType() {
	m.clearedmap_type = true
}

// MapTypeCleared returns if the edge map_type was cleared.
func (m *MetadataMutation) MapTypeCleared() bool {
	return m.clearedmap_type
}

// MapTypeID returns the map_type id in the mutation.
func (m *MetadataMutation) MapTypeID() (id int, exists bool) {
	if m.map_type != nil {
		return *m.map_type, true
	}
	return
}

// MapTypeIDs returns the map_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MapTypeID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) MapTypeIDs() (ids []int) {
	if id := m.map_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMapType reset all changes of the "map_type" edge.
func (m *MetadataMutation) ResetMapType() {
	m.map_type = nil
	m.clearedmap_type = false
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.data != nil {
		fields = append(fields, metadata.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, metadata.EdgeUser)
	}
	if m.map_type != nil {
		edges = append(edges, metadata.EdgeMapType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case metadata.EdgeMapType:
		if id := m.map_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, metadata.EdgeUser)
	}
	if m.clearedmap_type {
		edges = append(edges, metadata.EdgeMapType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeUser:
		return m.cleareduser
	case metadata.EdgeMapType:
		return m.clearedmap_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeUser:
		m.ClearUser()
		return nil
	case metadata.EdgeMapType:
		m.ClearMapType()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeUser:
		m.ResetUser()
		return nil
	case metadata.EdgeMapType:
		m.ResetMapType()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// PlayerMutation represents an operation that mutate the Players
// nodes in the graph.
type PlayerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	total_minutes      *int
	addtotal_minutes   *int
	session_started_at *time.Time
	session_ended_at   *time.Time
	last_seen_at       *time.Time
	clearedFields      map[string]struct{}
	metadata           *int
	clearedmetadata    bool
	servers            map[int]struct{}
	removedservers     map[int]struct{}
	clearedservers     bool
	user               *int
	cleareduser        bool
	identifiers        map[int]struct{}
	removedidentifiers map[int]struct{}
	clearedidentifiers bool
	done               bool
	oldValue           func(context.Context) (*Player, error)
	predicates         []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows to manage the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for Player.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the id field of the mutation.
func withPlayerID(id int) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *PlayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PlayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *PlayerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *PlayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PlayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *PlayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetTotalMinutes sets the total_minutes field.
func (m *PlayerMutation) SetTotalMinutes(i int) {
	m.total_minutes = &i
	m.addtotal_minutes = nil
}

// TotalMinutes returns the total_minutes value in the mutation.
func (m *PlayerMutation) TotalMinutes() (r int, exists bool) {
	v := m.total_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMinutes returns the old total_minutes value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldTotalMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalMinutes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMinutes: %w", err)
	}
	return oldValue.TotalMinutes, nil
}

// AddTotalMinutes adds i to total_minutes.
func (m *PlayerMutation) AddTotalMinutes(i int) {
	if m.addtotal_minutes != nil {
		*m.addtotal_minutes += i
	} else {
		m.addtotal_minutes = &i
	}
}

// AddedTotalMinutes returns the value that was added to the total_minutes field in this mutation.
func (m *PlayerMutation) AddedTotalMinutes() (r int, exists bool) {
	v := m.addtotal_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMinutes reset all changes of the "total_minutes" field.
func (m *PlayerMutation) ResetTotalMinutes() {
	m.total_minutes = nil
	m.addtotal_minutes = nil
}

// SetSessionStartedAt sets the session_started_at field.
func (m *PlayerMutation) SetSessionStartedAt(t time.Time) {
	m.session_started_at = &t
}

// SessionStartedAt returns the session_started_at value in the mutation.
func (m *PlayerMutation) SessionStartedAt() (r time.Time, exists bool) {
	v := m.session_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionStartedAt returns the old session_started_at value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldSessionStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSessionStartedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSessionStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionStartedAt: %w", err)
	}
	return oldValue.SessionStartedAt, nil
}

// ClearSessionStartedAt clears the value of session_started_at.
func (m *PlayerMutation) ClearSessionStartedAt() {
	m.session_started_at = nil
	m.clearedFields[player.FieldSessionStartedAt] = struct{}{}
}

// SessionStartedAtCleared returns if the field session_started_at was cleared in this mutation.
func (m *PlayerMutation) SessionStartedAtCleared() bool {
	_, ok := m.clearedFields[player.FieldSessionStartedAt]
	return ok
}

// ResetSessionStartedAt reset all changes of the "session_started_at" field.
func (m *PlayerMutation) ResetSessionStartedAt() {
	m.session_started_at = nil
	delete(m.clearedFields, player.FieldSessionStartedAt)
}

// SetSessionEndedAt sets the session_ended_at field.
func (m *PlayerMutation) SetSessionEndedAt(t time.Time) {
	m.session_ended_at = &t
}

// SessionEndedAt returns the session_ended_at value in the mutation.
func (m *PlayerMutation) SessionEndedAt() (r time.Time, exists bool) {
	v := m.session_ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionEndedAt returns the old session_ended_at value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldSessionEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSessionEndedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSessionEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionEndedAt: %w", err)
	}
	return oldValue.SessionEndedAt, nil
}

// ClearSessionEndedAt clears the value of session_ended_at.
func (m *PlayerMutation) ClearSessionEndedAt() {
	m.session_ended_at = nil
	m.clearedFields[player.FieldSessionEndedAt] = struct{}{}
}

// SessionEndedAtCleared returns if the field session_ended_at was cleared in this mutation.
func (m *PlayerMutation) SessionEndedAtCleared() bool {
	_, ok := m.clearedFields[player.FieldSessionEndedAt]
	return ok
}

// ResetSessionEndedAt reset all changes of the "session_ended_at" field.
func (m *PlayerMutation) ResetSessionEndedAt() {
	m.session_ended_at = nil
	delete(m.clearedFields, player.FieldSessionEndedAt)
}

// SetLastSeenAt sets the last_seen_at field.
func (m *PlayerMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the last_seen_at value in the mutation.
func (m *PlayerMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old last_seen_at value of the Player.
// If the Player object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerMutation) OldLastSeenAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastSeenAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of last_seen_at.
func (m *PlayerMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[player.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the field last_seen_at was cleared in this mutation.
func (m *PlayerMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[player.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt reset all changes of the "last_seen_at" field.
func (m *PlayerMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, player.FieldLastSeenAt)
}

// SetMetadataID sets the metadata edge to Metadata by id.
func (m *PlayerMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the metadata edge to Metadata.
func (m *PlayerMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared returns if the edge metadata was cleared.
func (m *PlayerMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the metadata id in the mutation.
func (m *PlayerMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the metadata ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata reset all changes of the "metadata" edge.
func (m *PlayerMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddServerIDs adds the servers edge to Server by ids.
func (m *PlayerMutation) AddServerIDs(ids ...int) {
	if m.servers == nil {
		m.servers = make(map[int]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the servers edge to Server.
func (m *PlayerMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared returns if the edge servers was cleared.
func (m *PlayerMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the servers edge to Server by ids.
func (m *PlayerMutation) RemoveServerIDs(ids ...int) {
	if m.removedservers == nil {
		m.removedservers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed ids of servers.
func (m *PlayerMutation) RemovedServersIDs() (ids []int) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the servers ids in the mutation.
func (m *PlayerMutation) ServersIDs() (ids []int) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers reset all changes of the "servers" edge.
func (m *PlayerMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// SetUserID sets the user edge to User by id.
func (m *PlayerMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *PlayerMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *PlayerMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *PlayerMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *PlayerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddIdentifierIDs adds the identifiers edge to PlayerIdentifier by ids.
func (m *PlayerMutation) AddIdentifierIDs(ids ...int) {
	if m.identifiers == nil {
		m.identifiers = make(map[int]struct{})
	}
	for i := range ids {
		m.identifiers[ids[i]] = struct{}{}
	}
}

// ClearIdentifiers clears the identifiers edge to PlayerIdentifier.
func (m *PlayerMutation) ClearIdentifiers() {
	m.clearedidentifiers = true
}

// IdentifiersCleared returns if the edge identifiers was cleared.
func (m *PlayerMutation) IdentifiersCleared() bool {
	return m.clearedidentifiers
}

// RemoveIdentifierIDs removes the identifiers edge to PlayerIdentifier by ids.
func (m *PlayerMutation) RemoveIdentifierIDs(ids ...int) {
	if m.removedidentifiers == nil {
		m.removedidentifiers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedidentifiers[ids[i]] = struct{}{}
	}
}

// RemovedIdentifiers returns the removed ids of identifiers.
func (m *PlayerMutation) RemovedIdentifiersIDs() (ids []int) {
	for id := range m.removedidentifiers {
		ids = append(ids, id)
	}
	return
}

// IdentifiersIDs returns the identifiers ids in the mutation.
func (m *PlayerMutation) IdentifiersIDs() (ids []int) {
	for id := range m.identifiers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentifiers reset all changes of the "identifiers" edge.
func (m *PlayerMutation) ResetIdentifiers() {
	m.identifiers = nil
	m.clearedidentifiers = false
	m.removedidentifiers = nil
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, player.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, player.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.total_minutes != nil {
		fields = append(fields, player.FieldTotalMinutes)
	}
	if m.session_started_at != nil {
		fields = append(fields, player.FieldSessionStartedAt)
	}
	if m.session_ended_at != nil {
		fields = append(fields, player.FieldSessionEndedAt)
	}
	if m.last_seen_at != nil {
		fields = append(fields, player.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldCreatedAt:
		return m.CreatedAt()
	case player.FieldUpdatedAt:
		return m.UpdatedAt()
	case player.FieldName:
		return m.Name()
	case player.FieldTotalMinutes:
		return m.TotalMinutes()
	case player.FieldSessionStartedAt:
		return m.SessionStartedAt()
	case player.FieldSessionEndedAt:
		return m.SessionEndedAt()
	case player.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case player.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldTotalMinutes:
		return m.OldTotalMinutes(ctx)
	case player.FieldSessionStartedAt:
		return m.OldSessionStartedAt(ctx)
	case player.FieldSessionEndedAt:
		return m.OldSessionEndedAt(ctx)
	case player.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case player.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldTotalMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMinutes(v)
		return nil
	case player.FieldSessionStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionStartedAt(v)
		return nil
	case player.FieldSessionEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionEndedAt(v)
		return nil
	case player.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_minutes != nil {
		fields = append(fields, player.FieldTotalMinutes)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldTotalMinutes:
		return m.AddedTotalMinutes()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldTotalMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(player.FieldSessionStartedAt) {
		fields = append(fields, player.FieldSessionStartedAt)
	}
	if m.FieldCleared(player.FieldSessionEndedAt) {
		fields = append(fields, player.FieldSessionEndedAt)
	}
	if m.FieldCleared(player.FieldLastSeenAt) {
		fields = append(fields, player.FieldLastSeenAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	switch name {
	case player.FieldSessionStartedAt:
		m.ClearSessionStartedAt()
		return nil
	case player.FieldSessionEndedAt:
		m.ClearSessionEndedAt()
		return nil
	case player.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case player.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldTotalMinutes:
		m.ResetTotalMinutes()
		return nil
	case player.FieldSessionStartedAt:
		m.ResetSessionStartedAt()
		return nil
	case player.FieldSessionEndedAt:
		m.ResetSessionEndedAt()
		return nil
	case player.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.metadata != nil {
		edges = append(edges, player.EdgeMetadata)
	}
	if m.servers != nil {
		edges = append(edges, player.EdgeServers)
	}
	if m.user != nil {
		edges = append(edges, player.EdgeUser)
	}
	if m.identifiers != nil {
		edges = append(edges, player.EdgeIdentifiers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.identifiers))
		for id := range m.identifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedservers != nil {
		edges = append(edges, player.EdgeServers)
	}
	if m.removedidentifiers != nil {
		edges = append(edges, player.EdgeIdentifiers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.removedidentifiers))
		for id := range m.removedidentifiers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmetadata {
		edges = append(edges, player.EdgeMetadata)
	}
	if m.clearedservers {
		edges = append(edges, player.EdgeServers)
	}
	if m.cleareduser {
		edges = append(edges, player.EdgeUser)
	}
	if m.clearedidentifiers {
		edges = append(edges, player.EdgeIdentifiers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeMetadata:
		return m.clearedmetadata
	case player.EdgeServers:
		return m.clearedservers
	case player.EdgeUser:
		return m.cleareduser
	case player.EdgeIdentifiers:
		return m.clearedidentifiers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case player.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case player.EdgeServers:
		m.ResetServers()
		return nil
	case player.EdgeUser:
		m.ResetUser()
		return nil
	case player.EdgeIdentifiers:
		m.ResetIdentifiers()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// PlayerIdentifierMutation represents an operation that mutate the PlayerIdentifiers
// nodes in the graph.
type PlayerIdentifierMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	_type           *string
	identifier      *string
	clearedFields   map[string]struct{}
	metadata        *int
	clearedmetadata bool
	player          *int
	clearedplayer   bool
	done            bool
	oldValue        func(context.Context) (*PlayerIdentifier, error)
	predicates      []predicate.PlayerIdentifier
}

var _ ent.Mutation = (*PlayerIdentifierMutation)(nil)

// playeridentifierOption allows to manage the mutation configuration using functional options.
type playeridentifierOption func(*PlayerIdentifierMutation)

// newPlayerIdentifierMutation creates new mutation for PlayerIdentifier.
func newPlayerIdentifierMutation(c config, op Op, opts ...playeridentifierOption) *PlayerIdentifierMutation {
	m := &PlayerIdentifierMutation{
		config:        c,
		op:            op,
		typ:           TypePlayerIdentifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerIdentifierID sets the id field of the mutation.
func withPlayerIdentifierID(id int) playeridentifierOption {
	return func(m *PlayerIdentifierMutation) {
		var (
			err   error
			once  sync.Once
			value *PlayerIdentifier
		)
		m.oldValue = func(ctx context.Context) (*PlayerIdentifier, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlayerIdentifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayerIdentifier sets the old PlayerIdentifier of the mutation.
func withPlayerIdentifier(node *PlayerIdentifier) playeridentifierOption {
	return func(m *PlayerIdentifierMutation) {
		m.oldValue = func(context.Context) (*PlayerIdentifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerIdentifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerIdentifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PlayerIdentifierMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *PlayerIdentifierMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PlayerIdentifierMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the PlayerIdentifier.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerIdentifierMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *PlayerIdentifierMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *PlayerIdentifierMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PlayerIdentifierMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the PlayerIdentifier.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerIdentifierMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *PlayerIdentifierMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the type field.
func (m *PlayerIdentifierMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *PlayerIdentifierMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the PlayerIdentifier.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerIdentifierMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *PlayerIdentifierMutation) ResetType() {
	m._type = nil
}

// SetIdentifier sets the identifier field.
func (m *PlayerIdentifierMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the identifier value in the mutation.
func (m *PlayerIdentifierMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old identifier value of the PlayerIdentifier.
// If the PlayerIdentifier object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PlayerIdentifierMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdentifier is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier reset all changes of the "identifier" field.
func (m *PlayerIdentifierMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetMetadataID sets the metadata edge to Metadata by id.
func (m *PlayerIdentifierMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the metadata edge to Metadata.
func (m *PlayerIdentifierMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared returns if the edge metadata was cleared.
func (m *PlayerIdentifierMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the metadata id in the mutation.
func (m *PlayerIdentifierMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the metadata ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *PlayerIdentifierMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata reset all changes of the "metadata" edge.
func (m *PlayerIdentifierMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// SetPlayerID sets the player edge to Player by id.
func (m *PlayerIdentifierMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the player edge to Player.
func (m *PlayerIdentifierMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared returns if the edge player was cleared.
func (m *PlayerIdentifierMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the player id in the mutation.
func (m *PlayerIdentifierMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the player ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *PlayerIdentifierMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer reset all changes of the "player" edge.
func (m *PlayerIdentifierMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// Op returns the operation name.
func (m *PlayerIdentifierMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PlayerIdentifier).
func (m *PlayerIdentifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PlayerIdentifierMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, playeridentifier.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, playeridentifier.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, playeridentifier.FieldType)
	}
	if m.identifier != nil {
		fields = append(fields, playeridentifier.FieldIdentifier)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PlayerIdentifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playeridentifier.FieldCreatedAt:
		return m.CreatedAt()
	case playeridentifier.FieldUpdatedAt:
		return m.UpdatedAt()
	case playeridentifier.FieldType:
		return m.GetType()
	case playeridentifier.FieldIdentifier:
		return m.Identifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PlayerIdentifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playeridentifier.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case playeridentifier.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case playeridentifier.FieldType:
		return m.OldType(ctx)
	case playeridentifier.FieldIdentifier:
		return m.OldIdentifier(ctx)
	}
	return nil, fmt.Errorf("unknown PlayerIdentifier field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlayerIdentifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playeridentifier.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case playeridentifier.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case playeridentifier.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case playeridentifier.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PlayerIdentifierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PlayerIdentifierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlayerIdentifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlayerIdentifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PlayerIdentifierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PlayerIdentifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerIdentifierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlayerIdentifier nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PlayerIdentifierMutation) ResetField(name string) error {
	switch name {
	case playeridentifier.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case playeridentifier.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case playeridentifier.FieldType:
		m.ResetType()
		return nil
	case playeridentifier.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PlayerIdentifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.metadata != nil {
		edges = append(edges, playeridentifier.EdgeMetadata)
	}
	if m.player != nil {
		edges = append(edges, playeridentifier.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PlayerIdentifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playeridentifier.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case playeridentifier.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PlayerIdentifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PlayerIdentifierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PlayerIdentifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmetadata {
		edges = append(edges, playeridentifier.EdgeMetadata)
	}
	if m.clearedplayer {
		edges = append(edges, playeridentifier.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PlayerIdentifierMutation) EdgeCleared(name string) bool {
	switch name {
	case playeridentifier.EdgeMetadata:
		return m.clearedmetadata
	case playeridentifier.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PlayerIdentifierMutation) ClearEdge(name string) error {
	switch name {
	case playeridentifier.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case playeridentifier.EdgePlayer:
		m.ClearPlayer()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PlayerIdentifierMutation) ResetEdge(name string) error {
	switch name {
	case playeridentifier.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case playeridentifier.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown PlayerIdentifier edge %s", name)
}

// ServerMutation represents an operation that mutate the Servers
// nodes in the graph.
type ServerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	api_username       *string
	api_secret         *string
	api_address        *string
	api_port           *string
	clearedFields      map[string]struct{}
	metadata           *int
	clearedmetadata    bool
	server_type        *int
	clearedserver_type bool
	map_type           *int
	clearedmap_type    bool
	players            map[int]struct{}
	removedplayers     map[int]struct{}
	clearedplayers     bool
	done               bool
	oldValue           func(context.Context) (*Server, error)
	predicates         []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows to manage the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for Server.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the id field of the mutation.
func withServerID(id int) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ServerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ServerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ServerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ServerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ServerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ServerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *ServerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServerMutation) ResetName() {
	m.name = nil
}

// SetAPIUsername sets the api_username field.
func (m *ServerMutation) SetAPIUsername(s string) {
	m.api_username = &s
}

// APIUsername returns the api_username value in the mutation.
func (m *ServerMutation) APIUsername() (r string, exists bool) {
	v := m.api_username
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIUsername returns the old api_username value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldAPIUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAPIUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAPIUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIUsername: %w", err)
	}
	return oldValue.APIUsername, nil
}

// ClearAPIUsername clears the value of api_username.
func (m *ServerMutation) ClearAPIUsername() {
	m.api_username = nil
	m.clearedFields[server.FieldAPIUsername] = struct{}{}
}

// APIUsernameCleared returns if the field api_username was cleared in this mutation.
func (m *ServerMutation) APIUsernameCleared() bool {
	_, ok := m.clearedFields[server.FieldAPIUsername]
	return ok
}

// ResetAPIUsername reset all changes of the "api_username" field.
func (m *ServerMutation) ResetAPIUsername() {
	m.api_username = nil
	delete(m.clearedFields, server.FieldAPIUsername)
}

// SetAPISecret sets the api_secret field.
func (m *ServerMutation) SetAPISecret(s string) {
	m.api_secret = &s
}

// APISecret returns the api_secret value in the mutation.
func (m *ServerMutation) APISecret() (r string, exists bool) {
	v := m.api_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAPISecret returns the old api_secret value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldAPISecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAPISecret is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAPISecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPISecret: %w", err)
	}
	return oldValue.APISecret, nil
}

// ClearAPISecret clears the value of api_secret.
func (m *ServerMutation) ClearAPISecret() {
	m.api_secret = nil
	m.clearedFields[server.FieldAPISecret] = struct{}{}
}

// APISecretCleared returns if the field api_secret was cleared in this mutation.
func (m *ServerMutation) APISecretCleared() bool {
	_, ok := m.clearedFields[server.FieldAPISecret]
	return ok
}

// ResetAPISecret reset all changes of the "api_secret" field.
func (m *ServerMutation) ResetAPISecret() {
	m.api_secret = nil
	delete(m.clearedFields, server.FieldAPISecret)
}

// SetAPIAddress sets the api_address field.
func (m *ServerMutation) SetAPIAddress(s string) {
	m.api_address = &s
}

// APIAddress returns the api_address value in the mutation.
func (m *ServerMutation) APIAddress() (r string, exists bool) {
	v := m.api_address
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIAddress returns the old api_address value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldAPIAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAPIAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAPIAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIAddress: %w", err)
	}
	return oldValue.APIAddress, nil
}

// ClearAPIAddress clears the value of api_address.
func (m *ServerMutation) ClearAPIAddress() {
	m.api_address = nil
	m.clearedFields[server.FieldAPIAddress] = struct{}{}
}

// APIAddressCleared returns if the field api_address was cleared in this mutation.
func (m *ServerMutation) APIAddressCleared() bool {
	_, ok := m.clearedFields[server.FieldAPIAddress]
	return ok
}

// ResetAPIAddress reset all changes of the "api_address" field.
func (m *ServerMutation) ResetAPIAddress() {
	m.api_address = nil
	delete(m.clearedFields, server.FieldAPIAddress)
}

// SetAPIPort sets the api_port field.
func (m *ServerMutation) SetAPIPort(s string) {
	m.api_port = &s
}

// APIPort returns the api_port value in the mutation.
func (m *ServerMutation) APIPort() (r string, exists bool) {
	v := m.api_port
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIPort returns the old api_port value of the Server.
// If the Server object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerMutation) OldAPIPort(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAPIPort is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAPIPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIPort: %w", err)
	}
	return oldValue.APIPort, nil
}

// ClearAPIPort clears the value of api_port.
func (m *ServerMutation) ClearAPIPort() {
	m.api_port = nil
	m.clearedFields[server.FieldAPIPort] = struct{}{}
}

// APIPortCleared returns if the field api_port was cleared in this mutation.
func (m *ServerMutation) APIPortCleared() bool {
	_, ok := m.clearedFields[server.FieldAPIPort]
	return ok
}

// ResetAPIPort reset all changes of the "api_port" field.
func (m *ServerMutation) ResetAPIPort() {
	m.api_port = nil
	delete(m.clearedFields, server.FieldAPIPort)
}

// SetMetadataID sets the metadata edge to Metadata by id.
func (m *ServerMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the metadata edge to Metadata.
func (m *ServerMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared returns if the edge metadata was cleared.
func (m *ServerMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the metadata id in the mutation.
func (m *ServerMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the metadata ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata reset all changes of the "metadata" edge.
func (m *ServerMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// SetServerTypeID sets the server_type edge to ServerType by id.
func (m *ServerMutation) SetServerTypeID(id int) {
	m.server_type = &id
}

// ClearServerType clears the server_type edge to ServerType.
func (m *ServerMutation) ClearServerType() {
	m.clearedserver_type = true
}

// ServerTypeCleared returns if the edge server_type was cleared.
func (m *ServerMutation) ServerTypeCleared() bool {
	return m.clearedserver_type
}

// ServerTypeID returns the server_type id in the mutation.
func (m *ServerMutation) ServerTypeID() (id int, exists bool) {
	if m.server_type != nil {
		return *m.server_type, true
	}
	return
}

// ServerTypeIDs returns the server_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServerTypeID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) ServerTypeIDs() (ids []int) {
	if id := m.server_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerType reset all changes of the "server_type" edge.
func (m *ServerMutation) ResetServerType() {
	m.server_type = nil
	m.clearedserver_type = false
}

// SetMapTypeID sets the map_type edge to MapType by id.
func (m *ServerMutation) SetMapTypeID(id int) {
	m.map_type = &id
}

// ClearMapType clears the map_type edge to MapType.
func (m *ServerMutation) ClearMapType() {
	m.clearedmap_type = true
}

// MapTypeCleared returns if the edge map_type was cleared.
func (m *ServerMutation) MapTypeCleared() bool {
	return m.clearedmap_type
}

// MapTypeID returns the map_type id in the mutation.
func (m *ServerMutation) MapTypeID() (id int, exists bool) {
	if m.map_type != nil {
		return *m.map_type, true
	}
	return
}

// MapTypeIDs returns the map_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MapTypeID instead. It exists only for internal usage by the builders.
func (m *ServerMutation) MapTypeIDs() (ids []int) {
	if id := m.map_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMapType reset all changes of the "map_type" edge.
func (m *ServerMutation) ResetMapType() {
	m.map_type = nil
	m.clearedmap_type = false
}

// AddPlayerIDs adds the players edge to Player by ids.
func (m *ServerMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the players edge to Player.
func (m *ServerMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared returns if the edge players was cleared.
func (m *ServerMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the players edge to Player by ids.
func (m *ServerMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed ids of players.
func (m *ServerMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the players ids in the mutation.
func (m *ServerMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers reset all changes of the "players" edge.
func (m *ServerMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, server.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, server.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, server.FieldName)
	}
	if m.api_username != nil {
		fields = append(fields, server.FieldAPIUsername)
	}
	if m.api_secret != nil {
		fields = append(fields, server.FieldAPISecret)
	}
	if m.api_address != nil {
		fields = append(fields, server.FieldAPIAddress)
	}
	if m.api_port != nil {
		fields = append(fields, server.FieldAPIPort)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldCreatedAt:
		return m.CreatedAt()
	case server.FieldUpdatedAt:
		return m.UpdatedAt()
	case server.FieldName:
		return m.Name()
	case server.FieldAPIUsername:
		return m.APIUsername()
	case server.FieldAPISecret:
		return m.APISecret()
	case server.FieldAPIAddress:
		return m.APIAddress()
	case server.FieldAPIPort:
		return m.APIPort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case server.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case server.FieldName:
		return m.OldName(ctx)
	case server.FieldAPIUsername:
		return m.OldAPIUsername(ctx)
	case server.FieldAPISecret:
		return m.OldAPISecret(ctx)
	case server.FieldAPIAddress:
		return m.OldAPIAddress(ctx)
	case server.FieldAPIPort:
		return m.OldAPIPort(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case server.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case server.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case server.FieldAPIUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIUsername(v)
		return nil
	case server.FieldAPISecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPISecret(v)
		return nil
	case server.FieldAPIAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIAddress(v)
		return nil
	case server.FieldAPIPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIPort(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(server.FieldAPIUsername) {
		fields = append(fields, server.FieldAPIUsername)
	}
	if m.FieldCleared(server.FieldAPISecret) {
		fields = append(fields, server.FieldAPISecret)
	}
	if m.FieldCleared(server.FieldAPIAddress) {
		fields = append(fields, server.FieldAPIAddress)
	}
	if m.FieldCleared(server.FieldAPIPort) {
		fields = append(fields, server.FieldAPIPort)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	switch name {
	case server.FieldAPIUsername:
		m.ClearAPIUsername()
		return nil
	case server.FieldAPISecret:
		m.ClearAPISecret()
		return nil
	case server.FieldAPIAddress:
		m.ClearAPIAddress()
		return nil
	case server.FieldAPIPort:
		m.ClearAPIPort()
		return nil
	}
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case server.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case server.FieldName:
		m.ResetName()
		return nil
	case server.FieldAPIUsername:
		m.ResetAPIUsername()
		return nil
	case server.FieldAPISecret:
		m.ResetAPISecret()
		return nil
	case server.FieldAPIAddress:
		m.ResetAPIAddress()
		return nil
	case server.FieldAPIPort:
		m.ResetAPIPort()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.metadata != nil {
		edges = append(edges, server.EdgeMetadata)
	}
	if m.server_type != nil {
		edges = append(edges, server.EdgeServerType)
	}
	if m.map_type != nil {
		edges = append(edges, server.EdgeMapType)
	}
	if m.players != nil {
		edges = append(edges, server.EdgePlayers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case server.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeServerType:
		if id := m.server_type; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgeMapType:
		if id := m.map_type; id != nil {
			return []ent.Value{*id}
		}
	case server.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedplayers != nil {
		edges = append(edges, server.EdgePlayers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case server.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmetadata {
		edges = append(edges, server.EdgeMetadata)
	}
	if m.clearedserver_type {
		edges = append(edges, server.EdgeServerType)
	}
	if m.clearedmap_type {
		edges = append(edges, server.EdgeMapType)
	}
	if m.clearedplayers {
		edges = append(edges, server.EdgePlayers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	switch name {
	case server.EdgeMetadata:
		return m.clearedmetadata
	case server.EdgeServerType:
		return m.clearedserver_type
	case server.EdgeMapType:
		return m.clearedmap_type
	case server.EdgePlayers:
		return m.clearedplayers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	switch name {
	case server.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case server.EdgeServerType:
		m.ClearServerType()
		return nil
	case server.EdgeMapType:
		m.ClearMapType()
		return nil
	}
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	switch name {
	case server.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case server.EdgeServerType:
		m.ResetServerType()
		return nil
	case server.EdgeMapType:
		m.ResetMapType()
		return nil
	case server.EdgePlayers:
		m.ResetPlayers()
		return nil
	}
	return fmt.Errorf("unknown Server edge %s", name)
}

// ServerTypeMutation represents an operation that mutate the ServerTypes
// nodes in the graph.
type ServerTypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	key            *string
	name           *string
	description    *string
	clearedFields  map[string]struct{}
	servers        map[int]struct{}
	removedservers map[int]struct{}
	clearedservers bool
	done           bool
	oldValue       func(context.Context) (*ServerType, error)
	predicates     []predicate.ServerType
}

var _ ent.Mutation = (*ServerTypeMutation)(nil)

// servertypeOption allows to manage the mutation configuration using functional options.
type servertypeOption func(*ServerTypeMutation)

// newServerTypeMutation creates new mutation for ServerType.
func newServerTypeMutation(c config, op Op, opts ...servertypeOption) *ServerTypeMutation {
	m := &ServerTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServerType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerTypeID sets the id field of the mutation.
func withServerTypeID(id int) servertypeOption {
	return func(m *ServerTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerType
		)
		m.oldValue = func(ctx context.Context) (*ServerType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerType sets the old ServerType of the mutation.
func withServerType(node *ServerType) servertypeOption {
	return func(m *ServerTypeMutation) {
		m.oldValue = func(context.Context) (*ServerType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServerTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKey sets the key field.
func (m *ServerTypeMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the key value in the mutation.
func (m *ServerTypeMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old key value of the ServerType.
// If the ServerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerTypeMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey reset all changes of the "key" field.
func (m *ServerTypeMutation) ResetKey() {
	m.key = nil
}

// SetName sets the name field.
func (m *ServerTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ServerTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ServerType.
// If the ServerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ServerTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *ServerTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ServerTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the ServerType.
// If the ServerType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServerTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *ServerTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servertype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *ServerTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servertype.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *ServerTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servertype.FieldDescription)
}

// AddServerIDs adds the servers edge to Server by ids.
func (m *ServerTypeMutation) AddServerIDs(ids ...int) {
	if m.servers == nil {
		m.servers = make(map[int]struct{})
	}
	for i := range ids {
		m.servers[ids[i]] = struct{}{}
	}
}

// ClearServers clears the servers edge to Server.
func (m *ServerTypeMutation) ClearServers() {
	m.clearedservers = true
}

// ServersCleared returns if the edge servers was cleared.
func (m *ServerTypeMutation) ServersCleared() bool {
	return m.clearedservers
}

// RemoveServerIDs removes the servers edge to Server by ids.
func (m *ServerTypeMutation) RemoveServerIDs(ids ...int) {
	if m.removedservers == nil {
		m.removedservers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservers[ids[i]] = struct{}{}
	}
}

// RemovedServers returns the removed ids of servers.
func (m *ServerTypeMutation) RemovedServersIDs() (ids []int) {
	for id := range m.removedservers {
		ids = append(ids, id)
	}
	return
}

// ServersIDs returns the servers ids in the mutation.
func (m *ServerTypeMutation) ServersIDs() (ids []int) {
	for id := range m.servers {
		ids = append(ids, id)
	}
	return
}

// ResetServers reset all changes of the "servers" edge.
func (m *ServerTypeMutation) ResetServers() {
	m.servers = nil
	m.clearedservers = false
	m.removedservers = nil
}

// Op returns the operation name.
func (m *ServerTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ServerType).
func (m *ServerTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServerTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, servertype.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, servertype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, servertype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServerTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servertype.FieldKey:
		return m.Key()
	case servertype.FieldName:
		return m.Name()
	case servertype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServerTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servertype.FieldKey:
		return m.OldKey(ctx)
	case servertype.FieldName:
		return m.OldName(ctx)
	case servertype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ServerType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServerTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servertype.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case servertype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case servertype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ServerType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServerTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServerTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServerTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServerTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servertype.FieldDescription) {
		fields = append(fields, servertype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServerTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerTypeMutation) ClearField(name string) error {
	switch name {
	case servertype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ServerType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServerTypeMutation) ResetField(name string) error {
	switch name {
	case servertype.FieldKey:
		m.ResetKey()
		return nil
	case servertype.FieldName:
		m.ResetName()
		return nil
	case servertype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ServerType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServerTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.servers != nil {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServerTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servertype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.servers))
		for id := range m.servers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServerTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedservers != nil {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServerTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servertype.EdgeServers:
		ids := make([]ent.Value, 0, len(m.removedservers))
		for id := range m.removedservers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServerTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedservers {
		edges = append(edges, servertype.EdgeServers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServerTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servertype.EdgeServers:
		return m.clearedservers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServerTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServerTypeMutation) ResetEdge(name string) error {
	switch name {
	case servertype.EdgeServers:
		m.ResetServers()
		return nil
	}
	return fmt.Errorf("unknown ServerType edge %s", name)
}

// SessionMutation represents an operation that mutate the Sessions
// nodes in the graph.
type SessionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	ip_address      *string
	browser_name    *string
	browser_version *string
	device_os       *string
	device_type     *string
	terminated_at   *time.Time
	clearedFields   map[string]struct{}
	token           *int
	clearedtoken    bool
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Session, error)
	predicates      []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows to manage the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for Session.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the id field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the create_time field.
func (m *SessionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the create_time value in the mutation.
func (m *SessionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old create_time value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime reset all changes of the "create_time" field.
func (m *SessionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the update_time field.
func (m *SessionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the update_time value in the mutation.
func (m *SessionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old update_time value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime reset all changes of the "update_time" field.
func (m *SessionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIPAddress sets the ip_address field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the ip_address value in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old ip_address value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress reset all changes of the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetBrowserName sets the browser_name field.
func (m *SessionMutation) SetBrowserName(s string) {
	m.browser_name = &s
}

// BrowserName returns the browser_name value in the mutation.
func (m *SessionMutation) BrowserName() (r string, exists bool) {
	v := m.browser_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowserName returns the old browser_name value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldBrowserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrowserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrowserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowserName: %w", err)
	}
	return oldValue.BrowserName, nil
}

// ResetBrowserName reset all changes of the "browser_name" field.
func (m *SessionMutation) ResetBrowserName() {
	m.browser_name = nil
}

// SetBrowserVersion sets the browser_version field.
func (m *SessionMutation) SetBrowserVersion(s string) {
	m.browser_version = &s
}

// BrowserVersion returns the browser_version value in the mutation.
func (m *SessionMutation) BrowserVersion() (r string, exists bool) {
	v := m.browser_version
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowserVersion returns the old browser_version value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldBrowserVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrowserVersion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrowserVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowserVersion: %w", err)
	}
	return oldValue.BrowserVersion, nil
}

// ResetBrowserVersion reset all changes of the "browser_version" field.
func (m *SessionMutation) ResetBrowserVersion() {
	m.browser_version = nil
}

// SetDeviceOs sets the device_os field.
func (m *SessionMutation) SetDeviceOs(s string) {
	m.device_os = &s
}

// DeviceOs returns the device_os value in the mutation.
func (m *SessionMutation) DeviceOs() (r string, exists bool) {
	v := m.device_os
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceOs returns the old device_os value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldDeviceOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceOs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceOs: %w", err)
	}
	return oldValue.DeviceOs, nil
}

// ResetDeviceOs reset all changes of the "device_os" field.
func (m *SessionMutation) ResetDeviceOs() {
	m.device_os = nil
}

// SetDeviceType sets the device_type field.
func (m *SessionMutation) SetDeviceType(s string) {
	m.device_type = &s
}

// DeviceType returns the device_type value in the mutation.
func (m *SessionMutation) DeviceType() (r string, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old device_type value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldDeviceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ResetDeviceType reset all changes of the "device_type" field.
func (m *SessionMutation) ResetDeviceType() {
	m.device_type = nil
}

// SetTerminatedAt sets the terminated_at field.
func (m *SessionMutation) SetTerminatedAt(t time.Time) {
	m.terminated_at = &t
}

// TerminatedAt returns the terminated_at value in the mutation.
func (m *SessionMutation) TerminatedAt() (r time.Time, exists bool) {
	v := m.terminated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminatedAt returns the old terminated_at value of the Session.
// If the Session object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SessionMutation) OldTerminatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTerminatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTerminatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminatedAt: %w", err)
	}
	return oldValue.TerminatedAt, nil
}

// ClearTerminatedAt clears the value of terminated_at.
func (m *SessionMutation) ClearTerminatedAt() {
	m.terminated_at = nil
	m.clearedFields[session.FieldTerminatedAt] = struct{}{}
}

// TerminatedAtCleared returns if the field terminated_at was cleared in this mutation.
func (m *SessionMutation) TerminatedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldTerminatedAt]
	return ok
}

// ResetTerminatedAt reset all changes of the "terminated_at" field.
func (m *SessionMutation) ResetTerminatedAt() {
	m.terminated_at = nil
	delete(m.clearedFields, session.FieldTerminatedAt)
}

// SetTokenID sets the token edge to Token by id.
func (m *SessionMutation) SetTokenID(id int) {
	m.token = &id
}

// ClearToken clears the token edge to Token.
func (m *SessionMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared returns if the edge token was cleared.
func (m *SessionMutation) TokenCleared() bool {
	return m.clearedtoken
}

// TokenID returns the token id in the mutation.
func (m *SessionMutation) TokenID() (id int, exists bool) {
	if m.token != nil {
		return *m.token, true
	}
	return
}

// TokenIDs returns the token ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TokenID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) TokenIDs() (ids []int) {
	if id := m.token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToken reset all changes of the "token" edge.
func (m *SessionMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
}

// SetUserID sets the user edge to User by id.
func (m *SessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *SessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, session.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, session.FieldUpdateTime)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.browser_name != nil {
		fields = append(fields, session.FieldBrowserName)
	}
	if m.browser_version != nil {
		fields = append(fields, session.FieldBrowserVersion)
	}
	if m.device_os != nil {
		fields = append(fields, session.FieldDeviceOs)
	}
	if m.device_type != nil {
		fields = append(fields, session.FieldDeviceType)
	}
	if m.terminated_at != nil {
		fields = append(fields, session.FieldTerminatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreateTime:
		return m.CreateTime()
	case session.FieldUpdateTime:
		return m.UpdateTime()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldBrowserName:
		return m.BrowserName()
	case session.FieldBrowserVersion:
		return m.BrowserVersion()
	case session.FieldDeviceOs:
		return m.DeviceOs()
	case session.FieldDeviceType:
		return m.DeviceType()
	case session.FieldTerminatedAt:
		return m.TerminatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case session.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldBrowserName:
		return m.OldBrowserName(ctx)
	case session.FieldBrowserVersion:
		return m.OldBrowserVersion(ctx)
	case session.FieldDeviceOs:
		return m.OldDeviceOs(ctx)
	case session.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case session.FieldTerminatedAt:
		return m.OldTerminatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case session.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldBrowserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowserName(v)
		return nil
	case session.FieldBrowserVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowserVersion(v)
		return nil
	case session.FieldDeviceOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceOs(v)
		return nil
	case session.FieldDeviceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case session.FieldTerminatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldTerminatedAt) {
		fields = append(fields, session.FieldTerminatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldTerminatedAt:
		m.ClearTerminatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case session.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldBrowserName:
		m.ResetBrowserName()
		return nil
	case session.FieldBrowserVersion:
		m.ResetBrowserVersion()
		return nil
	case session.FieldDeviceOs:
		m.ResetDeviceOs()
		return nil
	case session.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case session.FieldTerminatedAt:
		m.ResetTerminatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.token != nil {
		edges = append(edges, session.EdgeToken)
	}
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeToken:
		if id := m.token; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtoken {
		edges = append(edges, session.EdgeToken)
	}
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeToken:
		return m.clearedtoken
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeToken:
		m.ClearToken()
		return nil
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeToken:
		m.ResetToken()
		return nil
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TokenMutation represents an operation that mutate the Tokens
// nodes in the graph.
type TokenMutation struct {
	config
	op             Op
	typ            string
	id             *int
	expired_at     *time.Time
	blocked_at     *time.Time
	claims         *string
	clearedFields  map[string]struct{}
	session        *int
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*Token, error)
	predicates     []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows to manage the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for Token.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the id field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExpiredAt sets the expired_at field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the expired_at value in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old expired_at value of the Token.
// If the Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiredAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt reset all changes of the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetBlockedAt sets the blocked_at field.
func (m *TokenMutation) SetBlockedAt(t time.Time) {
	m.blocked_at = &t
}

// BlockedAt returns the blocked_at value in the mutation.
func (m *TokenMutation) BlockedAt() (r time.Time, exists bool) {
	v := m.blocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockedAt returns the old blocked_at value of the Token.
// If the Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TokenMutation) OldBlockedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBlockedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBlockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockedAt: %w", err)
	}
	return oldValue.BlockedAt, nil
}

// ClearBlockedAt clears the value of blocked_at.
func (m *TokenMutation) ClearBlockedAt() {
	m.blocked_at = nil
	m.clearedFields[token.FieldBlockedAt] = struct{}{}
}

// BlockedAtCleared returns if the field blocked_at was cleared in this mutation.
func (m *TokenMutation) BlockedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldBlockedAt]
	return ok
}

// ResetBlockedAt reset all changes of the "blocked_at" field.
func (m *TokenMutation) ResetBlockedAt() {
	m.blocked_at = nil
	delete(m.clearedFields, token.FieldBlockedAt)
}

// SetClaims sets the claims field.
func (m *TokenMutation) SetClaims(s string) {
	m.claims = &s
}

// Claims returns the claims value in the mutation.
func (m *TokenMutation) Claims() (r string, exists bool) {
	v := m.claims
	if v == nil {
		return
	}
	return *v, true
}

// OldClaims returns the old claims value of the Token.
// If the Token object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TokenMutation) OldClaims(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClaims is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClaims requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaims: %w", err)
	}
	return oldValue.Claims, nil
}

// ResetClaims reset all changes of the "claims" field.
func (m *TokenMutation) ResetClaims() {
	m.claims = nil
}

// SetSessionID sets the session edge to Session by id.
func (m *TokenMutation) SetSessionID(id int) {
	m.session = &id
}

// ClearSession clears the session edge to Session.
func (m *TokenMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared returns if the edge session was cleared.
func (m *TokenMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the session id in the mutation.
func (m *TokenMutation) SessionID() (id int, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the session ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) SessionIDs() (ids []int) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession reset all changes of the "session" edge.
func (m *TokenMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	if m.blocked_at != nil {
		fields = append(fields, token.FieldBlockedAt)
	}
	if m.claims != nil {
		fields = append(fields, token.FieldClaims)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	case token.FieldBlockedAt:
		return m.BlockedAt()
	case token.FieldClaims:
		return m.Claims()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case token.FieldBlockedAt:
		return m.OldBlockedAt(ctx)
	case token.FieldClaims:
		return m.OldClaims(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case token.FieldBlockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockedAt(v)
		return nil
	case token.FieldClaims:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaims(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldBlockedAt) {
		fields = append(fields, token.FieldBlockedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldBlockedAt:
		m.ClearBlockedAt()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case token.FieldBlockedAt:
		m.ResetBlockedAt()
		return nil
	case token.FieldClaims:
		m.ResetClaims()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, token.EdgeSession)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, token.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	email              *string
	password           *string
	is_system          *bool
	disabled_at        *time.Time
	disabled_reason    *string
	activated_at       *time.Time
	activation_comment *string
	clearedFields      map[string]struct{}
	metadata           *int
	clearedmetadata    bool
	sessions           map[int]struct{}
	removedsessions    map[int]struct{}
	clearedsessions    bool
	activation         *int
	clearedactivation  bool
	activations        map[int]struct{}
	removedactivations map[int]struct{}
	clearedactivations bool
	players            map[int]struct{}
	removedplayers     map[int]struct{}
	clearedplayers     bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for User.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of password.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the field password was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetIsSystem sets the is_system field.
func (m *UserMutation) SetIsSystem(b bool) {
	m.is_system = &b
}

// IsSystem returns the is_system value in the mutation.
func (m *UserMutation) IsSystem() (r bool, exists bool) {
	v := m.is_system
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSystem returns the old is_system value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIsSystem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsSystem is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSystem: %w", err)
	}
	return oldValue.IsSystem, nil
}

// ResetIsSystem reset all changes of the "is_system" field.
func (m *UserMutation) ResetIsSystem() {
	m.is_system = nil
}

// SetDisabledAt sets the disabled_at field.
func (m *UserMutation) SetDisabledAt(t time.Time) {
	m.disabled_at = &t
}

// DisabledAt returns the disabled_at value in the mutation.
func (m *UserMutation) DisabledAt() (r time.Time, exists bool) {
	v := m.disabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabledAt returns the old disabled_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDisabledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabledAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabledAt: %w", err)
	}
	return oldValue.DisabledAt, nil
}

// ClearDisabledAt clears the value of disabled_at.
func (m *UserMutation) ClearDisabledAt() {
	m.disabled_at = nil
	m.clearedFields[user.FieldDisabledAt] = struct{}{}
}

// DisabledAtCleared returns if the field disabled_at was cleared in this mutation.
func (m *UserMutation) DisabledAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDisabledAt]
	return ok
}

// ResetDisabledAt reset all changes of the "disabled_at" field.
func (m *UserMutation) ResetDisabledAt() {
	m.disabled_at = nil
	delete(m.clearedFields, user.FieldDisabledAt)
}

// SetDisabledReason sets the disabled_reason field.
func (m *UserMutation) SetDisabledReason(s string) {
	m.disabled_reason = &s
}

// DisabledReason returns the disabled_reason value in the mutation.
func (m *UserMutation) DisabledReason() (r string, exists bool) {
	v := m.disabled_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabledReason returns the old disabled_reason value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDisabledReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabledReason is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabledReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabledReason: %w", err)
	}
	return oldValue.DisabledReason, nil
}

// ClearDisabledReason clears the value of disabled_reason.
func (m *UserMutation) ClearDisabledReason() {
	m.disabled_reason = nil
	m.clearedFields[user.FieldDisabledReason] = struct{}{}
}

// DisabledReasonCleared returns if the field disabled_reason was cleared in this mutation.
func (m *UserMutation) DisabledReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldDisabledReason]
	return ok
}

// ResetDisabledReason reset all changes of the "disabled_reason" field.
func (m *UserMutation) ResetDisabledReason() {
	m.disabled_reason = nil
	delete(m.clearedFields, user.FieldDisabledReason)
}

// SetActivatedAt sets the activated_at field.
func (m *UserMutation) SetActivatedAt(t time.Time) {
	m.activated_at = &t
}

// ActivatedAt returns the activated_at value in the mutation.
func (m *UserMutation) ActivatedAt() (r time.Time, exists bool) {
	v := m.activated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldActivatedAt returns the old activated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldActivatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivatedAt: %w", err)
	}
	return oldValue.ActivatedAt, nil
}

// ClearActivatedAt clears the value of activated_at.
func (m *UserMutation) ClearActivatedAt() {
	m.activated_at = nil
	m.clearedFields[user.FieldActivatedAt] = struct{}{}
}

// ActivatedAtCleared returns if the field activated_at was cleared in this mutation.
func (m *UserMutation) ActivatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldActivatedAt]
	return ok
}

// ResetActivatedAt reset all changes of the "activated_at" field.
func (m *UserMutation) ResetActivatedAt() {
	m.activated_at = nil
	delete(m.clearedFields, user.FieldActivatedAt)
}

// SetActivationComment sets the activation_comment field.
func (m *UserMutation) SetActivationComment(s string) {
	m.activation_comment = &s
}

// ActivationComment returns the activation_comment value in the mutation.
func (m *UserMutation) ActivationComment() (r string, exists bool) {
	v := m.activation_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldActivationComment returns the old activation_comment value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldActivationComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivationComment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivationComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivationComment: %w", err)
	}
	return oldValue.ActivationComment, nil
}

// ClearActivationComment clears the value of activation_comment.
func (m *UserMutation) ClearActivationComment() {
	m.activation_comment = nil
	m.clearedFields[user.FieldActivationComment] = struct{}{}
}

// ActivationCommentCleared returns if the field activation_comment was cleared in this mutation.
func (m *UserMutation) ActivationCommentCleared() bool {
	_, ok := m.clearedFields[user.FieldActivationComment]
	return ok
}

// ResetActivationComment reset all changes of the "activation_comment" field.
func (m *UserMutation) ResetActivationComment() {
	m.activation_comment = nil
	delete(m.clearedFields, user.FieldActivationComment)
}

// SetMetadataID sets the metadata edge to Metadata by id.
func (m *UserMutation) SetMetadataID(id int) {
	m.metadata = &id
}

// ClearMetadata clears the metadata edge to Metadata.
func (m *UserMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared returns if the edge metadata was cleared.
func (m *UserMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// MetadataID returns the metadata id in the mutation.
func (m *UserMutation) MetadataID() (id int, exists bool) {
	if m.metadata != nil {
		return *m.metadata, true
	}
	return
}

// MetadataIDs returns the metadata ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MetadataIDs() (ids []int) {
	if id := m.metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata reset all changes of the "metadata" edge.
func (m *UserMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
}

// AddSessionIDs adds the sessions edge to Session by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the sessions edge to Session.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared returns if the edge sessions was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the sessions edge to Session by ids.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed ids of sessions.
func (m *UserMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the sessions ids in the mutation.
func (m *UserMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions reset all changes of the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// SetActivationID sets the activation edge to Activation by id.
func (m *UserMutation) SetActivationID(id int) {
	m.activation = &id
}

// ClearActivation clears the activation edge to Activation.
func (m *UserMutation) ClearActivation() {
	m.clearedactivation = true
}

// ActivationCleared returns if the edge activation was cleared.
func (m *UserMutation) ActivationCleared() bool {
	return m.clearedactivation
}

// ActivationID returns the activation id in the mutation.
func (m *UserMutation) ActivationID() (id int, exists bool) {
	if m.activation != nil {
		return *m.activation, true
	}
	return
}

// ActivationIDs returns the activation ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActivationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ActivationIDs() (ids []int) {
	if id := m.activation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivation reset all changes of the "activation" edge.
func (m *UserMutation) ResetActivation() {
	m.activation = nil
	m.clearedactivation = false
}

// AddActivationIDs adds the activations edge to Activation by ids.
func (m *UserMutation) AddActivationIDs(ids ...int) {
	if m.activations == nil {
		m.activations = make(map[int]struct{})
	}
	for i := range ids {
		m.activations[ids[i]] = struct{}{}
	}
}

// ClearActivations clears the activations edge to Activation.
func (m *UserMutation) ClearActivations() {
	m.clearedactivations = true
}

// ActivationsCleared returns if the edge activations was cleared.
func (m *UserMutation) ActivationsCleared() bool {
	return m.clearedactivations
}

// RemoveActivationIDs removes the activations edge to Activation by ids.
func (m *UserMutation) RemoveActivationIDs(ids ...int) {
	if m.removedactivations == nil {
		m.removedactivations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedactivations[ids[i]] = struct{}{}
	}
}

// RemovedActivations returns the removed ids of activations.
func (m *UserMutation) RemovedActivationsIDs() (ids []int) {
	for id := range m.removedactivations {
		ids = append(ids, id)
	}
	return
}

// ActivationsIDs returns the activations ids in the mutation.
func (m *UserMutation) ActivationsIDs() (ids []int) {
	for id := range m.activations {
		ids = append(ids, id)
	}
	return
}

// ResetActivations reset all changes of the "activations" edge.
func (m *UserMutation) ResetActivations() {
	m.activations = nil
	m.clearedactivations = false
	m.removedactivations = nil
}

// AddPlayerIDs adds the players edge to Player by ids.
func (m *UserMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the players edge to Player.
func (m *UserMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared returns if the edge players was cleared.
func (m *UserMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the players edge to Player by ids.
func (m *UserMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed ids of players.
func (m *UserMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the players ids in the mutation.
func (m *UserMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers reset all changes of the "players" edge.
func (m *UserMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_system != nil {
		fields = append(fields, user.FieldIsSystem)
	}
	if m.disabled_at != nil {
		fields = append(fields, user.FieldDisabledAt)
	}
	if m.disabled_reason != nil {
		fields = append(fields, user.FieldDisabledReason)
	}
	if m.activated_at != nil {
		fields = append(fields, user.FieldActivatedAt)
	}
	if m.activation_comment != nil {
		fields = append(fields, user.FieldActivationComment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsSystem:
		return m.IsSystem()
	case user.FieldDisabledAt:
		return m.DisabledAt()
	case user.FieldDisabledReason:
		return m.DisabledReason()
	case user.FieldActivatedAt:
		return m.ActivatedAt()
	case user.FieldActivationComment:
		return m.ActivationComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsSystem:
		return m.OldIsSystem(ctx)
	case user.FieldDisabledAt:
		return m.OldDisabledAt(ctx)
	case user.FieldDisabledReason:
		return m.OldDisabledReason(ctx)
	case user.FieldActivatedAt:
		return m.OldActivatedAt(ctx)
	case user.FieldActivationComment:
		return m.OldActivationComment(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsSystem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSystem(v)
		return nil
	case user.FieldDisabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabledAt(v)
		return nil
	case user.FieldDisabledReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabledReason(v)
		return nil
	case user.FieldActivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivatedAt(v)
		return nil
	case user.FieldActivationComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivationComment(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldDisabledAt) {
		fields = append(fields, user.FieldDisabledAt)
	}
	if m.FieldCleared(user.FieldDisabledReason) {
		fields = append(fields, user.FieldDisabledReason)
	}
	if m.FieldCleared(user.FieldActivatedAt) {
		fields = append(fields, user.FieldActivatedAt)
	}
	if m.FieldCleared(user.FieldActivationComment) {
		fields = append(fields, user.FieldActivationComment)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldDisabledAt:
		m.ClearDisabledAt()
		return nil
	case user.FieldDisabledReason:
		m.ClearDisabledReason()
		return nil
	case user.FieldActivatedAt:
		m.ClearActivatedAt()
		return nil
	case user.FieldActivationComment:
		m.ClearActivationComment()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsSystem:
		m.ResetIsSystem()
		return nil
	case user.FieldDisabledAt:
		m.ResetDisabledAt()
		return nil
	case user.FieldDisabledReason:
		m.ResetDisabledReason()
		return nil
	case user.FieldActivatedAt:
		m.ResetActivatedAt()
		return nil
	case user.FieldActivationComment:
		m.ResetActivationComment()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.metadata != nil {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.activation != nil {
		edges = append(edges, user.EdgeActivation)
	}
	if m.activations != nil {
		edges = append(edges, user.EdgeActivations)
	}
	if m.players != nil {
		edges = append(edges, user.EdgePlayers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMetadata:
		if id := m.metadata; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivation:
		if id := m.activation; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeActivations:
		ids := make([]ent.Value, 0, len(m.activations))
		for id := range m.activations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedactivations != nil {
		edges = append(edges, user.EdgeActivations)
	}
	if m.removedplayers != nil {
		edges = append(edges, user.EdgePlayers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivations:
		ids := make([]ent.Value, 0, len(m.removedactivations))
		for id := range m.removedactivations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmetadata {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedactivation {
		edges = append(edges, user.EdgeActivation)
	}
	if m.clearedactivations {
		edges = append(edges, user.EdgeActivations)
	}
	if m.clearedplayers {
		edges = append(edges, user.EdgePlayers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeMetadata:
		return m.clearedmetadata
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeActivation:
		return m.clearedactivation
	case user.EdgeActivations:
		return m.clearedactivations
	case user.EdgePlayers:
		return m.clearedplayers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case user.EdgeActivation:
		m.ClearActivation()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeActivation:
		m.ResetActivation()
		return nil
	case user.EdgeActivations:
		m.ResetActivations()
		return nil
	case user.EdgePlayers:
		m.ResetPlayers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
