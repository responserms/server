// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/facebook/ent/dialect/sql"
	"github.com/responserms/server/ent/activation"
	"github.com/responserms/server/ent/authsession"
	"github.com/responserms/server/ent/maplayer"
	"github.com/responserms/server/ent/maptype"
	"github.com/responserms/server/ent/metadata"
	"github.com/responserms/server/ent/metadataschema"
	"github.com/responserms/server/ent/player"
	"github.com/responserms/server/ent/playeridentifier"
	"github.com/responserms/server/ent/server"
	"github.com/responserms/server/ent/servertype"
	"github.com/responserms/server/ent/sessiontoken"
	"github.com/responserms/server/ent/user"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// ActivationEdge is the edge representation of Activation.
type ActivationEdge struct {
	Node   *Activation `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ActivationConnection is the connection containing edges to Activation.
type ActivationConnection struct {
	Edges      []*ActivationEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// ActivationPaginateOption enables pagination customization.
type ActivationPaginateOption func(*activationPager) error

// WithActivationOrder configures pagination ordering.
func WithActivationOrder(order *ActivationOrder) ActivationPaginateOption {
	if order == nil {
		order = DefaultActivationOrder
	}
	o := *order
	return func(pager *activationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultActivationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithActivationFilter configures pagination filter.
func WithActivationFilter(filter func(*ActivationQuery) (*ActivationQuery, error)) ActivationPaginateOption {
	return func(pager *activationPager) error {
		if filter == nil {
			return errors.New("ActivationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type activationPager struct {
	order  *ActivationOrder
	filter func(*ActivationQuery) (*ActivationQuery, error)
}

func newActivationPager(opts []ActivationPaginateOption) (*activationPager, error) {
	pager := &activationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultActivationOrder
	}
	return pager, nil
}

func (p *activationPager) applyFilter(query *ActivationQuery) (*ActivationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *activationPager) toCursor(a *Activation) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *activationPager) applyCursors(query *ActivationQuery, after, before *Cursor) *ActivationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultActivationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *activationPager) applyOrder(query *ActivationQuery, reverse bool) *ActivationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultActivationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultActivationOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Activation.
func (a *ActivationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ActivationPaginateOption,
) (*ActivationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newActivationPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &ActivationConnection{Edges: []*ActivationEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Activation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Activation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Activation {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ActivationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ActivationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ActivationOrderFieldCreatedAt orders Activation by created_at.
	ActivationOrderFieldCreatedAt = &ActivationOrderField{
		field: activation.FieldCreatedAt,
		toCursor: func(a *Activation) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// ActivationOrderFieldUpdatedAt orders Activation by updated_at.
	ActivationOrderFieldUpdatedAt = &ActivationOrderField{
		field: activation.FieldUpdatedAt,
		toCursor: func(a *Activation) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ActivationOrderField) String() string {
	var str string
	switch f.field {
	case activation.FieldCreatedAt:
		str = "CREATED_AT"
	case activation.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ActivationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ActivationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ActivationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ActivationOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ActivationOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ActivationOrderField", str)
	}
	return nil
}

// ActivationOrderField defines the ordering field of Activation.
type ActivationOrderField struct {
	field    string
	toCursor func(*Activation) Cursor
}

// ActivationOrder defines the ordering of Activation.
type ActivationOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ActivationOrderField `json:"field"`
}

// DefaultActivationOrder is the default ordering of Activation.
var DefaultActivationOrder = &ActivationOrder{
	Direction: OrderDirectionAsc,
	Field: &ActivationOrderField{
		field: activation.FieldID,
		toCursor: func(a *Activation) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Activation into ActivationEdge.
func (a *Activation) ToEdge(order *ActivationOrder) *ActivationEdge {
	if order == nil {
		order = DefaultActivationOrder
	}
	return &ActivationEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AuthSessionEdge is the edge representation of AuthSession.
type AuthSessionEdge struct {
	Node   *AuthSession `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AuthSessionConnection is the connection containing edges to AuthSession.
type AuthSessionConnection struct {
	Edges      []*AuthSessionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// AuthSessionPaginateOption enables pagination customization.
type AuthSessionPaginateOption func(*authSessionPager) error

// WithAuthSessionOrder configures pagination ordering.
func WithAuthSessionOrder(order *AuthSessionOrder) AuthSessionPaginateOption {
	if order == nil {
		order = DefaultAuthSessionOrder
	}
	o := *order
	return func(pager *authSessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthSessionFilter configures pagination filter.
func WithAuthSessionFilter(filter func(*AuthSessionQuery) (*AuthSessionQuery, error)) AuthSessionPaginateOption {
	return func(pager *authSessionPager) error {
		if filter == nil {
			return errors.New("AuthSessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authSessionPager struct {
	order  *AuthSessionOrder
	filter func(*AuthSessionQuery) (*AuthSessionQuery, error)
}

func newAuthSessionPager(opts []AuthSessionPaginateOption) (*authSessionPager, error) {
	pager := &authSessionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthSessionOrder
	}
	return pager, nil
}

func (p *authSessionPager) applyFilter(query *AuthSessionQuery) (*AuthSessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authSessionPager) toCursor(as *AuthSession) Cursor {
	return p.order.Field.toCursor(as)
}

func (p *authSessionPager) applyCursors(query *AuthSessionQuery, after, before *Cursor) *AuthSessionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAuthSessionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *authSessionPager) applyOrder(query *AuthSessionQuery, reverse bool) *AuthSessionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAuthSessionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAuthSessionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AuthSession.
func (as *AuthSessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthSessionPaginateOption,
) (*AuthSessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthSessionPager(opts)
	if err != nil {
		return nil, err
	}

	if as, err = pager.applyFilter(as); err != nil {
		return nil, err
	}

	conn := &AuthSessionConnection{Edges: []*AuthSessionEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := as.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := as.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	as = pager.applyCursors(as, after, before)
	as = pager.applyOrder(as, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		as = as.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		as = as.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := as.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AuthSession
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuthSession {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuthSession {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AuthSessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AuthSessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AuthSessionOrderField defines the ordering field of AuthSession.
type AuthSessionOrderField struct {
	field    string
	toCursor func(*AuthSession) Cursor
}

// AuthSessionOrder defines the ordering of AuthSession.
type AuthSessionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AuthSessionOrderField `json:"field"`
}

// DefaultAuthSessionOrder is the default ordering of AuthSession.
var DefaultAuthSessionOrder = &AuthSessionOrder{
	Direction: OrderDirectionAsc,
	Field: &AuthSessionOrderField{
		field: authsession.FieldID,
		toCursor: func(as *AuthSession) Cursor {
			return Cursor{ID: as.ID}
		},
	},
}

// ToEdge converts AuthSession into AuthSessionEdge.
func (as *AuthSession) ToEdge(order *AuthSessionOrder) *AuthSessionEdge {
	if order == nil {
		order = DefaultAuthSessionOrder
	}
	return &AuthSessionEdge{
		Node:   as,
		Cursor: order.Field.toCursor(as),
	}
}

// MapLayerEdge is the edge representation of MapLayer.
type MapLayerEdge struct {
	Node   *MapLayer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MapLayerConnection is the connection containing edges to MapLayer.
type MapLayerConnection struct {
	Edges      []*MapLayerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// MapLayerPaginateOption enables pagination customization.
type MapLayerPaginateOption func(*mapLayerPager) error

// WithMapLayerOrder configures pagination ordering.
func WithMapLayerOrder(order *MapLayerOrder) MapLayerPaginateOption {
	if order == nil {
		order = DefaultMapLayerOrder
	}
	o := *order
	return func(pager *mapLayerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMapLayerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMapLayerFilter configures pagination filter.
func WithMapLayerFilter(filter func(*MapLayerQuery) (*MapLayerQuery, error)) MapLayerPaginateOption {
	return func(pager *mapLayerPager) error {
		if filter == nil {
			return errors.New("MapLayerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mapLayerPager struct {
	order  *MapLayerOrder
	filter func(*MapLayerQuery) (*MapLayerQuery, error)
}

func newMapLayerPager(opts []MapLayerPaginateOption) (*mapLayerPager, error) {
	pager := &mapLayerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMapLayerOrder
	}
	return pager, nil
}

func (p *mapLayerPager) applyFilter(query *MapLayerQuery) (*MapLayerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mapLayerPager) toCursor(ml *MapLayer) Cursor {
	return p.order.Field.toCursor(ml)
}

func (p *mapLayerPager) applyCursors(query *MapLayerQuery, after, before *Cursor) *MapLayerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMapLayerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *mapLayerPager) applyOrder(query *MapLayerQuery, reverse bool) *MapLayerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMapLayerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMapLayerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to MapLayer.
func (ml *MapLayerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MapLayerPaginateOption,
) (*MapLayerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMapLayerPager(opts)
	if err != nil {
		return nil, err
	}

	if ml, err = pager.applyFilter(ml); err != nil {
		return nil, err
	}

	conn := &MapLayerConnection{Edges: []*MapLayerEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ml.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ml.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ml = pager.applyCursors(ml, after, before)
	ml = pager.applyOrder(ml, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ml = ml.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ml = ml.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ml.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *MapLayer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MapLayer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MapLayer {
			return nodes[i]
		}
	}

	conn.Edges = make([]*MapLayerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &MapLayerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// MapLayerOrderFieldCreatedAt orders MapLayer by created_at.
	MapLayerOrderFieldCreatedAt = &MapLayerOrderField{
		field: maplayer.FieldCreatedAt,
		toCursor: func(ml *MapLayer) Cursor {
			return Cursor{
				ID:    ml.ID,
				Value: ml.CreatedAt,
			}
		},
	}
	// MapLayerOrderFieldUpdatedAt orders MapLayer by updated_at.
	MapLayerOrderFieldUpdatedAt = &MapLayerOrderField{
		field: maplayer.FieldUpdatedAt,
		toCursor: func(ml *MapLayer) Cursor {
			return Cursor{
				ID:    ml.ID,
				Value: ml.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MapLayerOrderField) String() string {
	var str string
	switch f.field {
	case maplayer.FieldCreatedAt:
		str = "CREATED_AT"
	case maplayer.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MapLayerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MapLayerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MapLayerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MapLayerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MapLayerOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid MapLayerOrderField", str)
	}
	return nil
}

// MapLayerOrderField defines the ordering field of MapLayer.
type MapLayerOrderField struct {
	field    string
	toCursor func(*MapLayer) Cursor
}

// MapLayerOrder defines the ordering of MapLayer.
type MapLayerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MapLayerOrderField `json:"field"`
}

// DefaultMapLayerOrder is the default ordering of MapLayer.
var DefaultMapLayerOrder = &MapLayerOrder{
	Direction: OrderDirectionAsc,
	Field: &MapLayerOrderField{
		field: maplayer.FieldID,
		toCursor: func(ml *MapLayer) Cursor {
			return Cursor{ID: ml.ID}
		},
	},
}

// ToEdge converts MapLayer into MapLayerEdge.
func (ml *MapLayer) ToEdge(order *MapLayerOrder) *MapLayerEdge {
	if order == nil {
		order = DefaultMapLayerOrder
	}
	return &MapLayerEdge{
		Node:   ml,
		Cursor: order.Field.toCursor(ml),
	}
}

// MapTypeEdge is the edge representation of MapType.
type MapTypeEdge struct {
	Node   *MapType `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// MapTypeConnection is the connection containing edges to MapType.
type MapTypeConnection struct {
	Edges      []*MapTypeEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// MapTypePaginateOption enables pagination customization.
type MapTypePaginateOption func(*mapTypePager) error

// WithMapTypeOrder configures pagination ordering.
func WithMapTypeOrder(order *MapTypeOrder) MapTypePaginateOption {
	if order == nil {
		order = DefaultMapTypeOrder
	}
	o := *order
	return func(pager *mapTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMapTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMapTypeFilter configures pagination filter.
func WithMapTypeFilter(filter func(*MapTypeQuery) (*MapTypeQuery, error)) MapTypePaginateOption {
	return func(pager *mapTypePager) error {
		if filter == nil {
			return errors.New("MapTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mapTypePager struct {
	order  *MapTypeOrder
	filter func(*MapTypeQuery) (*MapTypeQuery, error)
}

func newMapTypePager(opts []MapTypePaginateOption) (*mapTypePager, error) {
	pager := &mapTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMapTypeOrder
	}
	return pager, nil
}

func (p *mapTypePager) applyFilter(query *MapTypeQuery) (*MapTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mapTypePager) toCursor(mt *MapType) Cursor {
	return p.order.Field.toCursor(mt)
}

func (p *mapTypePager) applyCursors(query *MapTypeQuery, after, before *Cursor) *MapTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMapTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *mapTypePager) applyOrder(query *MapTypeQuery, reverse bool) *MapTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMapTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMapTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to MapType.
func (mt *MapTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MapTypePaginateOption,
) (*MapTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMapTypePager(opts)
	if err != nil {
		return nil, err
	}

	if mt, err = pager.applyFilter(mt); err != nil {
		return nil, err
	}

	conn := &MapTypeConnection{Edges: []*MapTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := mt.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := mt.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	mt = pager.applyCursors(mt, after, before)
	mt = pager.applyOrder(mt, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		mt = mt.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		mt = mt.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := mt.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *MapType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MapType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MapType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*MapTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &MapTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// MapTypeOrderFieldCreatedAt orders MapType by created_at.
	MapTypeOrderFieldCreatedAt = &MapTypeOrderField{
		field: maptype.FieldCreatedAt,
		toCursor: func(mt *MapType) Cursor {
			return Cursor{
				ID:    mt.ID,
				Value: mt.CreatedAt,
			}
		},
	}
	// MapTypeOrderFieldUpdatedAt orders MapType by updated_at.
	MapTypeOrderFieldUpdatedAt = &MapTypeOrderField{
		field: maptype.FieldUpdatedAt,
		toCursor: func(mt *MapType) Cursor {
			return Cursor{
				ID:    mt.ID,
				Value: mt.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MapTypeOrderField) String() string {
	var str string
	switch f.field {
	case maptype.FieldCreatedAt:
		str = "CREATED_AT"
	case maptype.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MapTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MapTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MapTypeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MapTypeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MapTypeOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid MapTypeOrderField", str)
	}
	return nil
}

// MapTypeOrderField defines the ordering field of MapType.
type MapTypeOrderField struct {
	field    string
	toCursor func(*MapType) Cursor
}

// MapTypeOrder defines the ordering of MapType.
type MapTypeOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *MapTypeOrderField `json:"field"`
}

// DefaultMapTypeOrder is the default ordering of MapType.
var DefaultMapTypeOrder = &MapTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &MapTypeOrderField{
		field: maptype.FieldID,
		toCursor: func(mt *MapType) Cursor {
			return Cursor{ID: mt.ID}
		},
	},
}

// ToEdge converts MapType into MapTypeEdge.
func (mt *MapType) ToEdge(order *MapTypeOrder) *MapTypeEdge {
	if order == nil {
		order = DefaultMapTypeOrder
	}
	return &MapTypeEdge{
		Node:   mt,
		Cursor: order.Field.toCursor(mt),
	}
}

// MetadataEdge is the edge representation of Metadata.
type MetadataEdge struct {
	Node   *Metadata `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MetadataConnection is the connection containing edges to Metadata.
type MetadataConnection struct {
	Edges      []*MetadataEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// MetadataPaginateOption enables pagination customization.
type MetadataPaginateOption func(*metadataPager) error

// WithMetadataOrder configures pagination ordering.
func WithMetadataOrder(order *MetadataOrder) MetadataPaginateOption {
	if order == nil {
		order = DefaultMetadataOrder
	}
	o := *order
	return func(pager *metadataPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMetadataOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMetadataFilter configures pagination filter.
func WithMetadataFilter(filter func(*MetadataQuery) (*MetadataQuery, error)) MetadataPaginateOption {
	return func(pager *metadataPager) error {
		if filter == nil {
			return errors.New("MetadataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type metadataPager struct {
	order  *MetadataOrder
	filter func(*MetadataQuery) (*MetadataQuery, error)
}

func newMetadataPager(opts []MetadataPaginateOption) (*metadataPager, error) {
	pager := &metadataPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMetadataOrder
	}
	return pager, nil
}

func (p *metadataPager) applyFilter(query *MetadataQuery) (*MetadataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *metadataPager) toCursor(m *Metadata) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *metadataPager) applyCursors(query *MetadataQuery, after, before *Cursor) *MetadataQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMetadataOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *metadataPager) applyOrder(query *MetadataQuery, reverse bool) *MetadataQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMetadataOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMetadataOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Metadata.
func (m *MetadataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MetadataPaginateOption,
) (*MetadataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMetadataPager(opts)
	if err != nil {
		return nil, err
	}

	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}

	conn := &MetadataConnection{Edges: []*MetadataEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := m.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := m.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	m = pager.applyCursors(m, after, before)
	m = pager.applyOrder(m, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		m = m.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		m = m.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := m.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Metadata
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Metadata {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Metadata {
			return nodes[i]
		}
	}

	conn.Edges = make([]*MetadataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &MetadataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// MetadataOrderField defines the ordering field of Metadata.
type MetadataOrderField struct {
	field    string
	toCursor func(*Metadata) Cursor
}

// MetadataOrder defines the ordering of Metadata.
type MetadataOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MetadataOrderField `json:"field"`
}

// DefaultMetadataOrder is the default ordering of Metadata.
var DefaultMetadataOrder = &MetadataOrder{
	Direction: OrderDirectionAsc,
	Field: &MetadataOrderField{
		field: metadata.FieldID,
		toCursor: func(m *Metadata) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Metadata into MetadataEdge.
func (m *Metadata) ToEdge(order *MetadataOrder) *MetadataEdge {
	if order == nil {
		order = DefaultMetadataOrder
	}
	return &MetadataEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// MetadataSchemaEdge is the edge representation of MetadataSchema.
type MetadataSchemaEdge struct {
	Node   *MetadataSchema `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// MetadataSchemaConnection is the connection containing edges to MetadataSchema.
type MetadataSchemaConnection struct {
	Edges      []*MetadataSchemaEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

// MetadataSchemaPaginateOption enables pagination customization.
type MetadataSchemaPaginateOption func(*metadataSchemaPager) error

// WithMetadataSchemaOrder configures pagination ordering.
func WithMetadataSchemaOrder(order *MetadataSchemaOrder) MetadataSchemaPaginateOption {
	if order == nil {
		order = DefaultMetadataSchemaOrder
	}
	o := *order
	return func(pager *metadataSchemaPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMetadataSchemaOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMetadataSchemaFilter configures pagination filter.
func WithMetadataSchemaFilter(filter func(*MetadataSchemaQuery) (*MetadataSchemaQuery, error)) MetadataSchemaPaginateOption {
	return func(pager *metadataSchemaPager) error {
		if filter == nil {
			return errors.New("MetadataSchemaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type metadataSchemaPager struct {
	order  *MetadataSchemaOrder
	filter func(*MetadataSchemaQuery) (*MetadataSchemaQuery, error)
}

func newMetadataSchemaPager(opts []MetadataSchemaPaginateOption) (*metadataSchemaPager, error) {
	pager := &metadataSchemaPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMetadataSchemaOrder
	}
	return pager, nil
}

func (p *metadataSchemaPager) applyFilter(query *MetadataSchemaQuery) (*MetadataSchemaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *metadataSchemaPager) toCursor(ms *MetadataSchema) Cursor {
	return p.order.Field.toCursor(ms)
}

func (p *metadataSchemaPager) applyCursors(query *MetadataSchemaQuery, after, before *Cursor) *MetadataSchemaQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMetadataSchemaOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *metadataSchemaPager) applyOrder(query *MetadataSchemaQuery, reverse bool) *MetadataSchemaQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMetadataSchemaOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMetadataSchemaOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to MetadataSchema.
func (ms *MetadataSchemaQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MetadataSchemaPaginateOption,
) (*MetadataSchemaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMetadataSchemaPager(opts)
	if err != nil {
		return nil, err
	}

	if ms, err = pager.applyFilter(ms); err != nil {
		return nil, err
	}

	conn := &MetadataSchemaConnection{Edges: []*MetadataSchemaEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ms.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := ms.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ms = pager.applyCursors(ms, after, before)
	ms = pager.applyOrder(ms, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ms = ms.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ms = ms.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ms.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *MetadataSchema
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MetadataSchema {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MetadataSchema {
			return nodes[i]
		}
	}

	conn.Edges = make([]*MetadataSchemaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &MetadataSchemaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// MetadataSchemaOrderFieldCreatedAt orders MetadataSchema by created_at.
	MetadataSchemaOrderFieldCreatedAt = &MetadataSchemaOrderField{
		field: metadataschema.FieldCreatedAt,
		toCursor: func(ms *MetadataSchema) Cursor {
			return Cursor{
				ID:    ms.ID,
				Value: ms.CreatedAt,
			}
		},
	}
	// MetadataSchemaOrderFieldUpdatedAt orders MetadataSchema by updated_at.
	MetadataSchemaOrderFieldUpdatedAt = &MetadataSchemaOrderField{
		field: metadataschema.FieldUpdatedAt,
		toCursor: func(ms *MetadataSchema) Cursor {
			return Cursor{
				ID:    ms.ID,
				Value: ms.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f MetadataSchemaOrderField) String() string {
	var str string
	switch f.field {
	case metadataschema.FieldCreatedAt:
		str = "CREATED_AT"
	case metadataschema.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f MetadataSchemaOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *MetadataSchemaOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("MetadataSchemaOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *MetadataSchemaOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *MetadataSchemaOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid MetadataSchemaOrderField", str)
	}
	return nil
}

// MetadataSchemaOrderField defines the ordering field of MetadataSchema.
type MetadataSchemaOrderField struct {
	field    string
	toCursor func(*MetadataSchema) Cursor
}

// MetadataSchemaOrder defines the ordering of MetadataSchema.
type MetadataSchemaOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *MetadataSchemaOrderField `json:"field"`
}

// DefaultMetadataSchemaOrder is the default ordering of MetadataSchema.
var DefaultMetadataSchemaOrder = &MetadataSchemaOrder{
	Direction: OrderDirectionAsc,
	Field: &MetadataSchemaOrderField{
		field: metadataschema.FieldID,
		toCursor: func(ms *MetadataSchema) Cursor {
			return Cursor{ID: ms.ID}
		},
	},
}

// ToEdge converts MetadataSchema into MetadataSchemaEdge.
func (ms *MetadataSchema) ToEdge(order *MetadataSchemaOrder) *MetadataSchemaEdge {
	if order == nil {
		order = DefaultMetadataSchemaOrder
	}
	return &MetadataSchemaEdge{
		Node:   ms,
		Cursor: order.Field.toCursor(ms),
	}
}

// PlayerEdge is the edge representation of Player.
type PlayerEdge struct {
	Node   *Player `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PlayerConnection is the connection containing edges to Player.
type PlayerConnection struct {
	Edges      []*PlayerEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// PlayerPaginateOption enables pagination customization.
type PlayerPaginateOption func(*playerPager) error

// WithPlayerOrder configures pagination ordering.
func WithPlayerOrder(order *PlayerOrder) PlayerPaginateOption {
	if order == nil {
		order = DefaultPlayerOrder
	}
	o := *order
	return func(pager *playerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerFilter configures pagination filter.
func WithPlayerFilter(filter func(*PlayerQuery) (*PlayerQuery, error)) PlayerPaginateOption {
	return func(pager *playerPager) error {
		if filter == nil {
			return errors.New("PlayerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playerPager struct {
	order  *PlayerOrder
	filter func(*PlayerQuery) (*PlayerQuery, error)
}

func newPlayerPager(opts []PlayerPaginateOption) (*playerPager, error) {
	pager := &playerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerOrder
	}
	return pager, nil
}

func (p *playerPager) applyFilter(query *PlayerQuery) (*PlayerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playerPager) toCursor(pl *Player) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *playerPager) applyCursors(query *PlayerQuery, after, before *Cursor) *PlayerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlayerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *playerPager) applyOrder(query *PlayerQuery, reverse bool) *PlayerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlayerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlayerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Player.
func (pl *PlayerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerPaginateOption,
) (*PlayerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerPager(opts)
	if err != nil {
		return nil, err
	}

	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}

	conn := &PlayerConnection{Edges: []*PlayerEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pl = pager.applyCursors(pl, after, before)
	pl = pager.applyOrder(pl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pl = pl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pl = pl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Player
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Player {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Player {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PlayerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PlayerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// PlayerOrderFieldCreatedAt orders Player by created_at.
	PlayerOrderFieldCreatedAt = &PlayerOrderField{
		field: player.FieldCreatedAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.CreatedAt,
			}
		},
	}
	// PlayerOrderFieldUpdatedAt orders Player by updated_at.
	PlayerOrderFieldUpdatedAt = &PlayerOrderField{
		field: player.FieldUpdatedAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.UpdatedAt,
			}
		},
	}
	// PlayerOrderFieldTotalMinutes orders Player by total_minutes.
	PlayerOrderFieldTotalMinutes = &PlayerOrderField{
		field: player.FieldTotalMinutes,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.TotalMinutes,
			}
		},
	}
	// PlayerOrderFieldSessionStartedAt orders Player by session_started_at.
	PlayerOrderFieldSessionStartedAt = &PlayerOrderField{
		field: player.FieldSessionStartedAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.SessionStartedAt,
			}
		},
	}
	// PlayerOrderFieldSessionEndedAt orders Player by session_ended_at.
	PlayerOrderFieldSessionEndedAt = &PlayerOrderField{
		field: player.FieldSessionEndedAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.SessionEndedAt,
			}
		},
	}
	// PlayerOrderFieldLastSeenAt orders Player by last_seen_at.
	PlayerOrderFieldLastSeenAt = &PlayerOrderField{
		field: player.FieldLastSeenAt,
		toCursor: func(pl *Player) Cursor {
			return Cursor{
				ID:    pl.ID,
				Value: pl.LastSeenAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PlayerOrderField) String() string {
	var str string
	switch f.field {
	case player.FieldCreatedAt:
		str = "CREATED_AT"
	case player.FieldUpdatedAt:
		str = "UPDATED_AT"
	case player.FieldTotalMinutes:
		str = "TOTAL_MINUTES"
	case player.FieldSessionStartedAt:
		str = "SESSION_STARTED_AT"
	case player.FieldSessionEndedAt:
		str = "SESSION_ENDED_AT"
	case player.FieldLastSeenAt:
		str = "LAST_SEEN_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PlayerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PlayerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PlayerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PlayerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PlayerOrderFieldUpdatedAt
	case "TOTAL_MINUTES":
		*f = *PlayerOrderFieldTotalMinutes
	case "SESSION_STARTED_AT":
		*f = *PlayerOrderFieldSessionStartedAt
	case "SESSION_ENDED_AT":
		*f = *PlayerOrderFieldSessionEndedAt
	case "LAST_SEEN_AT":
		*f = *PlayerOrderFieldLastSeenAt
	default:
		return fmt.Errorf("%s is not a valid PlayerOrderField", str)
	}
	return nil
}

// PlayerOrderField defines the ordering field of Player.
type PlayerOrderField struct {
	field    string
	toCursor func(*Player) Cursor
}

// PlayerOrder defines the ordering of Player.
type PlayerOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PlayerOrderField `json:"field"`
}

// DefaultPlayerOrder is the default ordering of Player.
var DefaultPlayerOrder = &PlayerOrder{
	Direction: OrderDirectionAsc,
	Field: &PlayerOrderField{
		field: player.FieldID,
		toCursor: func(pl *Player) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts Player into PlayerEdge.
func (pl *Player) ToEdge(order *PlayerOrder) *PlayerEdge {
	if order == nil {
		order = DefaultPlayerOrder
	}
	return &PlayerEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// PlayerIdentifierEdge is the edge representation of PlayerIdentifier.
type PlayerIdentifierEdge struct {
	Node   *PlayerIdentifier `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// PlayerIdentifierConnection is the connection containing edges to PlayerIdentifier.
type PlayerIdentifierConnection struct {
	Edges      []*PlayerIdentifierEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// PlayerIdentifierPaginateOption enables pagination customization.
type PlayerIdentifierPaginateOption func(*playerIdentifierPager) error

// WithPlayerIdentifierOrder configures pagination ordering.
func WithPlayerIdentifierOrder(order *PlayerIdentifierOrder) PlayerIdentifierPaginateOption {
	if order == nil {
		order = DefaultPlayerIdentifierOrder
	}
	o := *order
	return func(pager *playerIdentifierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlayerIdentifierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlayerIdentifierFilter configures pagination filter.
func WithPlayerIdentifierFilter(filter func(*PlayerIdentifierQuery) (*PlayerIdentifierQuery, error)) PlayerIdentifierPaginateOption {
	return func(pager *playerIdentifierPager) error {
		if filter == nil {
			return errors.New("PlayerIdentifierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type playerIdentifierPager struct {
	order  *PlayerIdentifierOrder
	filter func(*PlayerIdentifierQuery) (*PlayerIdentifierQuery, error)
}

func newPlayerIdentifierPager(opts []PlayerIdentifierPaginateOption) (*playerIdentifierPager, error) {
	pager := &playerIdentifierPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlayerIdentifierOrder
	}
	return pager, nil
}

func (p *playerIdentifierPager) applyFilter(query *PlayerIdentifierQuery) (*PlayerIdentifierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *playerIdentifierPager) toCursor(pi *PlayerIdentifier) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *playerIdentifierPager) applyCursors(query *PlayerIdentifierQuery, after, before *Cursor) *PlayerIdentifierQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPlayerIdentifierOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *playerIdentifierPager) applyOrder(query *PlayerIdentifierQuery, reverse bool) *PlayerIdentifierQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPlayerIdentifierOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPlayerIdentifierOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to PlayerIdentifier.
func (pi *PlayerIdentifierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlayerIdentifierPaginateOption,
) (*PlayerIdentifierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlayerIdentifierPager(opts)
	if err != nil {
		return nil, err
	}

	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}

	conn := &PlayerIdentifierConnection{Edges: []*PlayerIdentifierEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pi.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := pi.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pi = pager.applyCursors(pi, after, before)
	pi = pager.applyOrder(pi, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pi = pi.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pi = pi.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pi.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *PlayerIdentifier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlayerIdentifier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlayerIdentifier {
			return nodes[i]
		}
	}

	conn.Edges = make([]*PlayerIdentifierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &PlayerIdentifierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// PlayerIdentifierOrderFieldCreatedAt orders PlayerIdentifier by created_at.
	PlayerIdentifierOrderFieldCreatedAt = &PlayerIdentifierOrderField{
		field: playeridentifier.FieldCreatedAt,
		toCursor: func(pi *PlayerIdentifier) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.CreatedAt,
			}
		},
	}
	// PlayerIdentifierOrderFieldUpdatedAt orders PlayerIdentifier by updated_at.
	PlayerIdentifierOrderFieldUpdatedAt = &PlayerIdentifierOrderField{
		field: playeridentifier.FieldUpdatedAt,
		toCursor: func(pi *PlayerIdentifier) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PlayerIdentifierOrderField) String() string {
	var str string
	switch f.field {
	case playeridentifier.FieldCreatedAt:
		str = "CREATED_AT"
	case playeridentifier.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PlayerIdentifierOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PlayerIdentifierOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PlayerIdentifierOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PlayerIdentifierOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PlayerIdentifierOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PlayerIdentifierOrderField", str)
	}
	return nil
}

// PlayerIdentifierOrderField defines the ordering field of PlayerIdentifier.
type PlayerIdentifierOrderField struct {
	field    string
	toCursor func(*PlayerIdentifier) Cursor
}

// PlayerIdentifierOrder defines the ordering of PlayerIdentifier.
type PlayerIdentifierOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *PlayerIdentifierOrderField `json:"field"`
}

// DefaultPlayerIdentifierOrder is the default ordering of PlayerIdentifier.
var DefaultPlayerIdentifierOrder = &PlayerIdentifierOrder{
	Direction: OrderDirectionAsc,
	Field: &PlayerIdentifierOrderField{
		field: playeridentifier.FieldID,
		toCursor: func(pi *PlayerIdentifier) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts PlayerIdentifier into PlayerIdentifierEdge.
func (pi *PlayerIdentifier) ToEdge(order *PlayerIdentifierOrder) *PlayerIdentifierEdge {
	if order == nil {
		order = DefaultPlayerIdentifierOrder
	}
	return &PlayerIdentifierEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// ServerEdge is the edge representation of Server.
type ServerEdge struct {
	Node   *Server `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ServerConnection is the connection containing edges to Server.
type ServerConnection struct {
	Edges      []*ServerEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// ServerPaginateOption enables pagination customization.
type ServerPaginateOption func(*serverPager) error

// WithServerOrder configures pagination ordering.
func WithServerOrder(order *ServerOrder) ServerPaginateOption {
	if order == nil {
		order = DefaultServerOrder
	}
	o := *order
	return func(pager *serverPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServerFilter configures pagination filter.
func WithServerFilter(filter func(*ServerQuery) (*ServerQuery, error)) ServerPaginateOption {
	return func(pager *serverPager) error {
		if filter == nil {
			return errors.New("ServerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serverPager struct {
	order  *ServerOrder
	filter func(*ServerQuery) (*ServerQuery, error)
}

func newServerPager(opts []ServerPaginateOption) (*serverPager, error) {
	pager := &serverPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServerOrder
	}
	return pager, nil
}

func (p *serverPager) applyFilter(query *ServerQuery) (*ServerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serverPager) toCursor(s *Server) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *serverPager) applyCursors(query *ServerQuery, after, before *Cursor) *ServerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *serverPager) applyOrder(query *ServerQuery, reverse bool) *ServerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServerOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Server.
func (s *ServerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServerPaginateOption,
) (*ServerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServerPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &ServerConnection{Edges: []*ServerEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Server
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Server {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Server {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// ServerOrderFieldCreatedAt orders Server by created_at.
	ServerOrderFieldCreatedAt = &ServerOrderField{
		field: server.FieldCreatedAt,
		toCursor: func(s *Server) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// ServerOrderFieldUpdatedAt orders Server by updated_at.
	ServerOrderFieldUpdatedAt = &ServerOrderField{
		field: server.FieldUpdatedAt,
		toCursor: func(s *Server) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ServerOrderField) String() string {
	var str string
	switch f.field {
	case server.FieldCreatedAt:
		str = "CREATED_AT"
	case server.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ServerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ServerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ServerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ServerOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ServerOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ServerOrderField", str)
	}
	return nil
}

// ServerOrderField defines the ordering field of Server.
type ServerOrderField struct {
	field    string
	toCursor func(*Server) Cursor
}

// ServerOrder defines the ordering of Server.
type ServerOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ServerOrderField `json:"field"`
}

// DefaultServerOrder is the default ordering of Server.
var DefaultServerOrder = &ServerOrder{
	Direction: OrderDirectionAsc,
	Field: &ServerOrderField{
		field: server.FieldID,
		toCursor: func(s *Server) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Server into ServerEdge.
func (s *Server) ToEdge(order *ServerOrder) *ServerEdge {
	if order == nil {
		order = DefaultServerOrder
	}
	return &ServerEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ServerTypeEdge is the edge representation of ServerType.
type ServerTypeEdge struct {
	Node   *ServerType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ServerTypeConnection is the connection containing edges to ServerType.
type ServerTypeConnection struct {
	Edges      []*ServerTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// ServerTypePaginateOption enables pagination customization.
type ServerTypePaginateOption func(*serverTypePager) error

// WithServerTypeOrder configures pagination ordering.
func WithServerTypeOrder(order *ServerTypeOrder) ServerTypePaginateOption {
	if order == nil {
		order = DefaultServerTypeOrder
	}
	o := *order
	return func(pager *serverTypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServerTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServerTypeFilter configures pagination filter.
func WithServerTypeFilter(filter func(*ServerTypeQuery) (*ServerTypeQuery, error)) ServerTypePaginateOption {
	return func(pager *serverTypePager) error {
		if filter == nil {
			return errors.New("ServerTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serverTypePager struct {
	order  *ServerTypeOrder
	filter func(*ServerTypeQuery) (*ServerTypeQuery, error)
}

func newServerTypePager(opts []ServerTypePaginateOption) (*serverTypePager, error) {
	pager := &serverTypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServerTypeOrder
	}
	return pager, nil
}

func (p *serverTypePager) applyFilter(query *ServerTypeQuery) (*ServerTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serverTypePager) toCursor(st *ServerType) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *serverTypePager) applyCursors(query *ServerTypeQuery, after, before *Cursor) *ServerTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultServerTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *serverTypePager) applyOrder(query *ServerTypeQuery, reverse bool) *ServerTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultServerTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultServerTypeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ServerType.
func (st *ServerTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServerTypePaginateOption,
) (*ServerTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServerTypePager(opts)
	if err != nil {
		return nil, err
	}

	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}

	conn := &ServerTypeConnection{Edges: []*ServerTypeEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := st.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := st.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	st = pager.applyCursors(st, after, before)
	st = pager.applyOrder(st, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		st = st.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		st = st.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := st.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ServerType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServerType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServerType {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ServerTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ServerTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ServerTypeOrderField defines the ordering field of ServerType.
type ServerTypeOrderField struct {
	field    string
	toCursor func(*ServerType) Cursor
}

// ServerTypeOrder defines the ordering of ServerType.
type ServerTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ServerTypeOrderField `json:"field"`
}

// DefaultServerTypeOrder is the default ordering of ServerType.
var DefaultServerTypeOrder = &ServerTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &ServerTypeOrderField{
		field: servertype.FieldID,
		toCursor: func(st *ServerType) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// ToEdge converts ServerType into ServerTypeEdge.
func (st *ServerType) ToEdge(order *ServerTypeOrder) *ServerTypeEdge {
	if order == nil {
		order = DefaultServerTypeOrder
	}
	return &ServerTypeEdge{
		Node:   st,
		Cursor: order.Field.toCursor(st),
	}
}

// SessionTokenEdge is the edge representation of SessionToken.
type SessionTokenEdge struct {
	Node   *SessionToken `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// SessionTokenConnection is the connection containing edges to SessionToken.
type SessionTokenConnection struct {
	Edges      []*SessionTokenEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// SessionTokenPaginateOption enables pagination customization.
type SessionTokenPaginateOption func(*sessionTokenPager) error

// WithSessionTokenOrder configures pagination ordering.
func WithSessionTokenOrder(order *SessionTokenOrder) SessionTokenPaginateOption {
	if order == nil {
		order = DefaultSessionTokenOrder
	}
	o := *order
	return func(pager *sessionTokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSessionTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSessionTokenFilter configures pagination filter.
func WithSessionTokenFilter(filter func(*SessionTokenQuery) (*SessionTokenQuery, error)) SessionTokenPaginateOption {
	return func(pager *sessionTokenPager) error {
		if filter == nil {
			return errors.New("SessionTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sessionTokenPager struct {
	order  *SessionTokenOrder
	filter func(*SessionTokenQuery) (*SessionTokenQuery, error)
}

func newSessionTokenPager(opts []SessionTokenPaginateOption) (*sessionTokenPager, error) {
	pager := &sessionTokenPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSessionTokenOrder
	}
	return pager, nil
}

func (p *sessionTokenPager) applyFilter(query *SessionTokenQuery) (*SessionTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sessionTokenPager) toCursor(st *SessionToken) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *sessionTokenPager) applyCursors(query *SessionTokenQuery, after, before *Cursor) *SessionTokenQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSessionTokenOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sessionTokenPager) applyOrder(query *SessionTokenQuery, reverse bool) *SessionTokenQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSessionTokenOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSessionTokenOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to SessionToken.
func (st *SessionTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SessionTokenPaginateOption,
) (*SessionTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSessionTokenPager(opts)
	if err != nil {
		return nil, err
	}

	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}

	conn := &SessionTokenConnection{Edges: []*SessionTokenEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := st.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := st.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	st = pager.applyCursors(st, after, before)
	st = pager.applyOrder(st, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		st = st.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		st = st.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := st.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *SessionToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SessionToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SessionToken {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SessionTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SessionTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// SessionTokenOrderFieldCreatedAt orders SessionToken by created_at.
	SessionTokenOrderFieldCreatedAt = &SessionTokenOrderField{
		field: sessiontoken.FieldCreatedAt,
		toCursor: func(st *SessionToken) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.CreatedAt,
			}
		},
	}
	// SessionTokenOrderFieldUpdatedAt orders SessionToken by updated_at.
	SessionTokenOrderFieldUpdatedAt = &SessionTokenOrderField{
		field: sessiontoken.FieldUpdatedAt,
		toCursor: func(st *SessionToken) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SessionTokenOrderField) String() string {
	var str string
	switch f.field {
	case sessiontoken.FieldCreatedAt:
		str = "CREATED_AT"
	case sessiontoken.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SessionTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SessionTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SessionTokenOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SessionTokenOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SessionTokenOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid SessionTokenOrderField", str)
	}
	return nil
}

// SessionTokenOrderField defines the ordering field of SessionToken.
type SessionTokenOrderField struct {
	field    string
	toCursor func(*SessionToken) Cursor
}

// SessionTokenOrder defines the ordering of SessionToken.
type SessionTokenOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *SessionTokenOrderField `json:"field"`
}

// DefaultSessionTokenOrder is the default ordering of SessionToken.
var DefaultSessionTokenOrder = &SessionTokenOrder{
	Direction: OrderDirectionAsc,
	Field: &SessionTokenOrderField{
		field: sessiontoken.FieldID,
		toCursor: func(st *SessionToken) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// ToEdge converts SessionToken into SessionTokenEdge.
func (st *SessionToken) ToEdge(order *SessionTokenOrder) *SessionTokenEdge {
	if order == nil {
		order = DefaultSessionTokenOrder
	}
	return &SessionTokenEdge{
		Node:   st,
		Cursor: order.Field.toCursor(st),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}

	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) ||
		first != nil && *first == 0 ||
		last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := u.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) &&
		hasCollectedField(ctx, totalCountField) {
		count, err := u.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		u = u.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		u = u.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := u.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		field: user.FieldCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		field: user.FieldUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.field {
	case user.FieldCreatedAt:
		str = "CREATED_AT"
	case user.FieldUpdatedAt:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
