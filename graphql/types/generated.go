// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package types

import (
	"github.com/responserms/server/ent"
)

type CreateMapLayerInput struct {
	MapType     int    `json:"map_type"`
	Name        string `json:"name"`
	URLTemplate string `json:"url_template"`
	IsPublic    bool   `json:"is_public"`
}

type CreateMapTypeInput struct {
	Name    string  `json:"name"`
	MinZoom int     `json:"min_zoom"`
	MaxZoom int     `json:"max_zoom"`
	MinX    float64 `json:"min_x"`
	MinY    float64 `json:"min_y"`
	MaxX    float64 `json:"max_x"`
	MaxY    float64 `json:"max_y"`
}

type CreateServerInput struct {
	ServerType  int     `json:"server_type"`
	MapType     int     `json:"map_type"`
	Name        string  `json:"name"`
	APIUsername *string `json:"api_username"`
	APIPort     *string `json:"api_port"`
	APIAddress  *string `json:"api_address"`
	APISecret   *string `json:"api_secret"`
}

type FilterSessionToken struct {
	IsBlocked *bool `json:"is_blocked"`
	IsExpired *bool `json:"is_expired"`
}

// Login using the provided credentials.
type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// Returned when performing a `login` mutation. An access_token will be returned only when `logged_in` is true and no
// errors are present. If `require_mfa` returns true a secondary request to `loginMfa` is required to retrieve the
// access_token.
type LoginResult struct {
	LoggedIn    bool      `json:"logged_in"`
	RequireMfa  bool      `json:"require_mfa"`
	AccessToken *string   `json:"access_token"`
	User        *ent.User `json:"user"`
}

type MetadataValidationError struct {
	Path         *string     `json:"path"`
	InvalidValue interface{} `json:"invalidValue"`
	Message      string      `json:"message"`
}

type MetadataValidationStatus struct {
	Valid  bool                       `json:"valid"`
	Errors []*MetadataValidationError `json:"errors"`
}

// All pagination in the API should use a cursor. This input is the same for every API
// and allows the user to request records before and/or after a specific cursor (ID).
//
// By default the pagination limit is 25 and any other limit, as long as it is within
// the maximum that the administrator configures, can be requested by setting `limit`
// to the appropriate number of records to return in each response.
//
// Cursor-based pagination is sometimes more difficult to grasp than page-based
// pagination, however, it works better with continuous scrolling and when data is
// constantly changing. This is because cursors do not require that the data returned
// be static and no items will be skipped if they fall behind/ahead of the threshold
// before the next request.
//
// Note that although IDs returned from the API are string-based, they map back into
// numeric IDs in the database so all cursors use the actual identifier itself rather
// than the timestamp of the record referred to.
type PaginationInput struct {
	After  *ent.Cursor `json:"after"`
	First  *int        `json:"first"`
	Before *ent.Cursor `json:"before"`
	Last   *int        `json:"last"`
}

type PlayerFilter struct {
	Search *string `json:"search"`
	Online *bool   `json:"online"`
}

type PlayerIdentifierConstraintInput struct {
	Type       string `json:"type"`
	Identifier string `json:"identifier"`
}

// Register a User using the provided creentials and name.
type RegisterInput struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

// Returned when performing `register` mutation. An access_token will be returned when `registered` is true, no
// errors are present, and `pending` is false. If `pending` returns true the user must wait to be approved before
// being able to login to Response.
//
// The user may subscribe to the `userActivated` subscription with the ID returned in the `user` object to be
// notified when the account is activated.
type RegisterResult struct {
	AccessToken *string   `json:"access_token"`
	Registered  bool      `json:"registered"`
	Activated   bool      `json:"activated"`
	User        *ent.User `json:"user"`
}

type UpdateMapLayerInput struct {
	MapType     *int    `json:"map_type"`
	Name        *string `json:"name"`
	URLTemplate *string `json:"url_template"`
	IsPublic    *bool   `json:"is_public"`
}

type UpdateMapTypeInput struct {
	Name    *string  `json:"name"`
	MinZoom *int     `json:"min_zoom"`
	MaxZoom *int     `json:"max_zoom"`
	MinX    *float64 `json:"min_x"`
	MinY    *float64 `json:"min_y"`
	MaxX    *float64 `json:"max_x"`
	MaxY    *float64 `json:"max_y"`
}

type UpdateServerInput struct {
	ServerType  *int    `json:"server_type"`
	MapType     *int    `json:"map_type"`
	Name        *string `json:"name"`
	APIUsername *string `json:"api_username"`
	APIPort     *string `json:"api_port"`
	APIAddress  *string `json:"api_address"`
	APISecret   *string `json:"api_secret"`
}

type UpsertPlayerIdentifierInput struct {
	Type       string `json:"type"`
	Identifier string `json:"identifier"`
}

type UpsertPlayerInput struct {
	Name        string                         `json:"name"`
	AddMinutes  int                            `json:"add_minutes"`
	Identifiers []*UpsertPlayerIdentifierInput `json:"identifiers"`
}

// Returned when the userActivated subcription triggers.
type UserActivatedResult struct {
	Activated   bool      `json:"activated"`
	ActivatedBy *ent.User `json:"activated_by"`
	Comments    *string   `json:"comments"`
}

type UserFilter struct {
	Name      *string `json:"name"`
	NameLike  *string `json:"name_like"`
	Email     *string `json:"email"`
	EmailLike *string `json:"email_like"`
	Activated *bool   `json:"activated"`
	Disabled  *bool   `json:"disabled"`
}
