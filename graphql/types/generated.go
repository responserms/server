// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package types

import (
	"time"

	"github.com/responserms/server/ent"
)

type Error interface {
	IsError()
}

type LoginWithCredentialsError interface {
	IsLoginWithCredentialsError()
}

type RegisterWithCredentialsError interface {
	IsRegisterWithCredentialsError()
}

type RegisterWithProviderErrors interface {
	IsRegisterWithProviderErrors()
}

type AuthenticatingBrowserInput struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type AuthenticatingDeviceInput struct {
	OperatingSystem string `json:"operatingSystem"`
	Type            string `json:"type"`
}

type Credentials struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// This error is presented when the email provided belongs to an existing account.
type EmailAlreadyExistsError struct {
	Message string   `json:"message"`
	Path    []string `json:"path"`
}

func (EmailAlreadyExistsError) IsRegisterWithCredentialsError() {}
func (EmailAlreadyExistsError) IsError()                        {}

// This error is presented when an input path fails validation.
type InputIsInvalidError struct {
	Message string   `json:"message"`
	Path    []string `json:"path"`
}

func (InputIsInvalidError) IsLoginWithCredentialsError()    {}
func (InputIsInvalidError) IsRegisterWithCredentialsError() {}
func (InputIsInvalidError) IsRegisterWithProviderErrors()   {}
func (InputIsInvalidError) IsError()                        {}

// Returned when the credentials provided are invalid. This could mean the email is not registered or the password does not
// match the provided email address.
type InvalidCredentialsError struct {
	Message string   `json:"message"`
	Path    []string `json:"path"`
}

func (InvalidCredentialsError) IsError()                     {}
func (InvalidCredentialsError) IsLoginWithCredentialsError() {}

type LoginTokenPayload struct {
	AccessToken *string    `json:"access_token"`
	ExpiredAt   *time.Time `json:"expired_at"`
}

type LoginWithCredentialsInput struct {
	Credentials *Credentials                `json:"credentials"`
	Device      *AuthenticatingDeviceInput  `json:"device"`
	Browser     *AuthenticatingBrowserInput `json:"browser"`
}

type LoginWithCredentialsPayload struct {
	Errors []LoginWithCredentialsError `json:"errors"`
	Token  *LoginTokenPayload          `json:"token"`
}

type LoginWithProviderInput struct {
	Credentials *ProviderCredentialsInput `json:"credentials"`
}

type LoginWithProviderPayload struct {
	Errors []LoginWithCredentialsError `json:"errors"`
	Token  *LoginTokenPayload          `json:"token"`
}

type MetadataValidationError struct {
	Path         *string     `json:"path"`
	InvalidValue interface{} `json:"invalidValue"`
	Message      string      `json:"message"`
}

type MetadataValidationStatus struct {
	Valid  bool                       `json:"valid"`
	Errors []*MetadataValidationError `json:"errors"`
}

// All pagination in the API should use a cursor. This input is the same for every API
// and allows the user to request records before and/or after a specific cursor (ID).
//
// By default the pagination limit is 25 and any other limit, as long as it is within
// the maximum that the administrator configures, can be requested by setting `limit`
// to the appropriate number of records to return in each response.
//
// Cursor-based pagination is sometimes more difficult to grasp than page-based
// pagination, however, it works better with continuous scrolling and when data is
// constantly changing. This is because cursors do not require that the data returned
// be static and no items will be skipped if they fall behind/ahead of the threshold
// before the next request.
//
// Note that although IDs returned from the API are string-based, they map back into
// numeric IDs in the database so all cursors use the actual identifier itself rather
// than the timestamp of the record referred to.
type PaginationInput struct {
	After  *ent.Cursor `json:"after"`
	First  *int        `json:"first"`
	Before *ent.Cursor `json:"before"`
	Last   *int        `json:"last"`
}

// Returned when authentication is not allowed via password. This is typically the case when a password has been remoed from
// the user or the user has chosen to login with a social provider and never set a password.
type PasswordNotAllowedError struct {
	Message string   `json:"message"`
	Path    []string `json:"path"`
}

func (PasswordNotAllowedError) IsError()                     {}
func (PasswordNotAllowedError) IsLoginWithCredentialsError() {}

// This error is presented when the access token for the provider cannot be validated or has expired.
type ProviderAccessTokenError struct {
	Message string   `json:"message"`
	Path    []string `json:"path"`
}

func (ProviderAccessTokenError) IsRegisterWithProviderErrors() {}
func (ProviderAccessTokenError) IsError()                      {}

type ProviderCredentialsInput struct {
	Provider    int    `json:"provider"`
	AccessToken string `json:"access_token"`
}

type RegisterWithCredentialsInput struct {
	Name        string       `json:"name"`
	Credentials *Credentials `json:"credentials"`
}

type RegisterWithCredentialsPayload struct {
	Success bool                           `json:"success"`
	Errors  []RegisterWithCredentialsError `json:"errors"`
}

type RegisterWithProviderInput struct {
	Credentials *ProviderCredentialsInput `json:"credentials"`
}

type RegisterWithProviderPayload struct {
	Success bool                         `json:"success"`
	Errors  []RegisterWithProviderErrors `json:"errors"`
}

type SearchInput struct {
	Query string `json:"query"`
}

type UserFilter struct {
	Active   *bool        `json:"active"`
	Disabled *bool        `json:"disabled"`
	Search   *SearchInput `json:"search"`
}
